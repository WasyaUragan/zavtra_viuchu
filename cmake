###########
https://habr.com/ru/articles/155467/
-----------------------------------------------------
yum install cmake gcc gcc-c++
-----------------------------------------------------
mkdir cmake && cd cmake/
-----------------------------------------------------
vim main.cpp
#include <iostream>
int main(int argc, char** argv)
{
	std::cout << "Hello, World!" << std::endl;
	return 0;
}
-----------------------------------------------------
vim CMakeLists.txt
cmake_minimum_required(VERSION 2.8.12)
project(test)
set(CMAKE_SHARED_LIBRARY_PREFIX "")
set(CMAKE_EXPORT_COMPILE_COMMANDS 1)
add_executable(main main.cpp)

Переменные могут хранить списки значений, разделённых пробелами\табуляциями\переносами:
set(SOURCE main.cpp foo.cpp)
set(HEADER main.h
	    foo.h)

Что бы получить значение переменной ипользуем конструкцию:
${var_name}

Если тип библиотеки не указать («STATIC» или «SHARED»), по умолчанию она соберётся как статическая.
Имена библиотек указываются без стандартного префикса «lib».

Статическая библиотека это не что иное, как ar-архив, внутри которого лежат обычные объектники, никак не связаные между собой.
Объектные файлы в CMake стоят на ряду с исходниками — достаточно включить объектник в список файлов для компиляции.

С библиотеками:
add_library(netutil STATIC IMPORTED)
set_property(TARGET netutil PROPERTY
	     IMPORTED_LOCATION Binary/game_client/libnetutil.a)
	     
Слово «IMPORTED», указывает, что библиотека берётся извне.	     
В CMake каждая цель имеет параметры, а set_property позволяет их изменять.
Линкуется такая библиотека стандартно:
target_link_libraries(${TARGET} netutil)
Для динамических библиотек все аналогично, только тип «SHARED», расширение — ".so".
-----------------------------------------------------
mkdir tmp && cd tmp
-----------------------------------------------------
[root@fazzer-ziv tmp]# cmake /opt/cmake/
-- The CXX compiler identification is GNU 8.5.0
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /opt/cmake/tmp
-----------------------------------------------------
[root@fazzer-ziv tmp]# make
[ 50%] Building CXX object CMakeFiles/main.dir/main.cpp.o
[100%] Linking CXX executable main
[100%] Built target main
-----------------------------------------------------
[root@fazzer-ziv tmp]# ./main 
Hello, World!
-----------------------------------------------------
Папку tmp можно очищать\удалять без риска поломать исходники. Если CMakeLists.txt был изменен, то вызов make автоматически запустит cmake. Если исходники были перемещены, то нужно очистить временную директорию и запустить cmake вручную.
-----------------------------------------------------
Проекты на CMake можно объединять в довольно сложные иерархические структуры, причем каждый подпроект в реальности является самостоятельным проектом, который в свою очередь может сам состоять из подпроектов. Это позволяет легко разбить вашу программу на необходимое количество отдельных модулей. Примером такого подхода может служить KDE.
-----------------------------------------------------
Module dir:
ll /usr/share/cmake/Modules/
-----------------------------------------------------
Обье́ктный мо́дуль (также — объектный файл, англ. object file) — файл с промежуточным представлением отдельного модуля программы, полученный в результате обработки исходного кода компилятором. Объектный файл содержит в себе особым образом подготовленный код (часто называемый бинарным), который может быть объединён с другими объектными файлами при помощи редактора связей (компоновщика) для получения готового исполнимого модуля либо библиотеки.

Объектные файлы представляют собой блоки машинного кода и данных, с неопределенными адресами ссылок на данные и процедуры в других объектных модулях, а также список своих процедур и данных. Компоновщик собирает код и данные каждого объектного модуля в итоговую программу, вычисляет и заполняет адреса перекрестных ссылок между модулями. Также в процессе компоновки происходит связывание программы со статическими и динамическими библиотеками (являющихся архивами объектных файлов).
======================================================
MAKE
======================================================
hello: hello.c
Тут имеется правило, в котором сказано, что имеется файл hello, зависящий от файла hello.c. Если hello.c новее чем hello, то hello надо собрать.
-----------------------------------------------------
Eсли запустить make с опцией -n, то программа сообщит о том, что собирается делать, но при этом ничего делать не будет.
[root@fazzer-ziv cmake]# make -n
cc     hello.c   -o hello
-----------------------------------------------------
В сложных файлах Makefile можно настраивать уже применяемые опции:
CC=gcc
CFLAGS=-g  # Закомментируйте следующую строку для отключения оптимизации
CFLAGS+=-O
hello : hello.c

На самом деле, неявно используемое правило выглядит так:
$(CC) $(CFLAGS) $(CPPFLAGS) hello.c -o hello
-----------------------------------------------------
Переменные принято оформлять с использованием конструкции вида $().
Если имя переменной состоит всего из одного символа, то без скобок можно и обойтись (например — использовать конструкцию вроде $X), но лучше так не делать, так как работоспособность подобных конструкций в разных системах не гарантируется.
-----------------------------------------------------
Если начать строку с символа Tab (не с нескольких пробелов, а именно с настоящего Tab), тогда то, что находится в строке, будет восприниматься как команда запуска некоего скрипта, а не как правило. 

Чтобы сделать правила более гибкими, нужно использовать переменные — так же, как это делается в правилах, используемых по умолчанию. Ещё можно использовать символы-местозаполнители.

% : %.c
    $(CC) $(CPPFLAGS) $(CFLAGS) $< -o $@

Символ % — это универсальный местозаполнитель, соответствующий любой последовательности символов. В переменную $< попадает имя первого (и, в данном случае, единственного) реквизита, которым является hello.c.
Переменная $@ даёт нам имя цели (в данном примере — hello).
-----------------------------------------------------
all : hello libtest config-editor

Фиктивная цель:
.PHONY: all

К фиктивным целям можно прикреплять действия.
.PHONY: clean
clean: 
     rm *.o
     
Благодаря этому можно выполнить команду make clean для того чтобы удалить все объектные файлы. 
-----------------------------------------------------















































