Таблица стилей составлена из одной и более инструкций (называемых правилами или наборами правил), которые описывают, как элемент или группа элементов должны отображаться.

Согласно терминологии CSS существует две главные части правила — это селектор, устанавливающий элемент или элементы, на которые надо воздействовать, и определение, предоставляющее инструкции представления. Определение, в свою очередь, составлено из свойства (например, color) и его значения (green) , разделенных двоеточием и пробелом.

селектор        свойство            значение
    a {     background-color:        yellow; }

Допустимо использовать несколько определений в одном правиле

Каждое определение должно оканчиваться точкой с запятой для отделения его от следующего. Если вы пропустите этот знак препинания, то следующее за ним определение будет игнорироваться.

Фигурные скобки и заключенные в них определения часто называются блоком определения.

Присоединение CSS к HTML-документу

Метод 1: Встроенные стили (атрибут style)

<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Пример встроенных стилей</title>
 </head>
 <body> 
  <p style="color: red;">Это текст будет отображаться красным цветом</p>
 </body>
</html>

Метод 2: Глобальные таблицы стилей

<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Пример глобальных стилей</title>
  <style type="text/css">
   p { color: red; }
  </style>
 </head>
 <body> 
  <p>Это текст будет отображаться красным цветом</p>
 </body>
</html>

Метод 3: Внешние таблицы стилей

Рекомендуемый метод - создание ссылки на так называемую внешнюю таблицу стилей.
Внешняя таблица стилей - это просто текстовый файл с расширением .css.

<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8">
  <title>Пример глобальных стилей</title>
  <link rel="stylesheet" href="css/style.css">
 </head>
 <body>
  <p>Это текст будет отображаться красным цветом</p>
 </body>
</html>

 Самое важное здесь то, что несколько HTML-документов могут ссылаться на одну таблицу стилей

Комментарии в таблицах стилей

/* здесь находятся комментарии */

Текст, который содержится между символами /* и */, будет игнорироваться при анализе таблицы стилей, а значит, вы можете оставлять комментарии в любом месте таблицы стилей, даже внутри правила.

Если вам когда-нибудь понадобится применить одно и то же свойство к нескольким элементам, можете сгруппировать селекторы в одно правило, разделив их запятыми.
p, ul, a { color: navy; }

Селекторы по тегу
h1 {
    /* стили для всех h1 */
 }

Селекторы идентификатора
Селекторы идентификатора позволяют вам целенаправленно выбирать элементы по их id значениям. Символ, с помощью которого распознаются селекторы идентификатора, — знак числа #

<li id="catalog1234">Майка со смайликом</li>
li#catalogl234 { color: red; }
Из-за того, что значения id должны быть уникальными в документе, допускается пропустить имя элемента. Это правило эквивалентно по­следнему:
#catalog1234 { color: red; }

На практике селекторы идентификатора применяется не часто, вместо них рекомендуется использовать селектор класса, о котором узнаете далее.

Селекторы классов
Другим идентификатором элемента является идентификатор class, используемый для группировки элементов в одну концептуальную группу. В отличие от атрибута id, имя класса class могут разделять несколько элементов. Кроме того, элемент может принадлежать более чем одному классу.Ниже приведен пример, в котором заголовку h3 и двум абзацам назначен класс special.

<h3 class="special">Этот заголовок будет оранжевого цвета</h3>
<p>Этот текст будет стандартного цвета</p>
<p class="special">Этот текст будет оранжевого цвета</p>
<p class="special">Этот текст будет оранжевого цвета</p>

Имена клас­сов указываются при помощи точки (.) в селекторе.
p.special { color: orange; }

Чтобы применить свойство ко всем элементам одного класса, пропу­стите имя элемента в селекторе
.special { color: orange; }

Селекторы по атрибуту
<button data-my-custom-attribute="my-custom-value">
 Нажми на меня
</button>
Имя и значение атрибута пишется в квадратных скобках. Работает с любым атрибутом:
[data-my-custom-attribute="my-custom-value"] {
   color: red;
}

Любой элемент
* {
    margin: 0;
}

Составные селекторы
Составные селекторы состоят из комбинации простых.

Группировка селекторов
button,
.button,
.cta-button {}

Элемент с классом
Селектор выберет все p, у которых есть класс example.
p.example {}
Селектор выберет все элементы с классом main, у которых также есть и класс active.
.main.active {}

Селекторы потомков

Селектор потомков целенаправленно выбирает элементы, которые со­держатся внутри (и поэтому они потомки) другого элемента.

Потомком называются любые элементы, расположенные внутри родительского элемента. А дочерними элементами называются ближайшие потомки.

li em { color: olive; }
Символ пробела между име­нами элементов означает, что второй элемент должен содержаться внутри первого, это означает вложенность на любом уровне.
Таким образом, оливковым цветом будут выделены только элементы списка,  заключенные в тег em.

Правая угловая скобка > обозначает вложенность на первом уровне.
.page > p {
     text-decoration: underline;
}

Первый соседний элемент
Для того, чтобы выбрать элемент, который находится сразу после другого элемента, используется знак +.
img + p {
     margin-top: 0;
     font-style: italic;
}

Любой соседний элемент
Для того, чтобы выбрать элемент, который находится после другого элемента, используется знак ~. 

Хороший способ понимать смысл составных селекторов - читать их справа налево.

Когда мы используем определённый шрифт, мы указываем его имя в свойстве font-family:
Но у такого подхода есть одна проблема: если на устройстве пользователя нет этого шрифта, то он не увидит текста.
Эта проблема решается с помощью fallback (фоллбэк):
p {
    font-family: 'Roboto', 'Helvetica Nue', sans-serif;
 }
 В конце списка фоллбэк-шрифтов всегда указывается семейство, в которое входят предыдущие шрифты. Таким образом, если у пользователя нет конкретных, указанных нами шрифтов, то применится любой шрифт из указанного семейства, которой есть у него на устройстве.

 Единицы измерения:

 px – это самая базовая, абсолютная и окончательная единица измерения.

 1em – текущий размер шрифта.
 Можно брать любые пропорции от текущего шрифта: 2em, 0.5em и т.п.

 %
 Как правило, процент будет от значения свойства родителя с тем же названием, но не всегда.]
 При установке свойства margin-left в %, процент берётся от ширины родительского блока, а вовсе не от его margin-left.
При установке свойства line-height в %, процент берётся от текущего размера шрифта, а вовсе не от line-height родителя.
Для width/height обычно процент от ширины/высоты родителя, но при position:fixed, процент берётся от ширины/высоты окна (а не родителя и не документа). Кроме того, иногда % требует соблюдения дополнительных условий.

Единица rem задаёт размер относительно размера шрифта элемента <html>.

Относительно экрана: vw, vh, vmin, vmax
vw – 1% ширины окна
vh – 1% высоты окна
vmin – наименьшее из (vw, vh), в IE9 обозначается vm
vmax – наибольшее из (vw, vh)
Их основное преимущество – в том, что любые размеры, которые в них заданы, автоматически масштабируются при изменении размеров окна.

Переполнение контента
Свойство overflow управляет отображением содержания блочного элемента при переполнении.

Проблемы св-ва float
https://stepik.org/lesson/183598/step/3?unit=158194

Позиционирование

Тип позиционирования задаётся с помощью свойства position.

Статическое позиционирование (static)
Этот тип стоит у элементов по умолчанию. Элемент располагается в потоке относительно остальных элементов на странице. В потоке, то есть в таком порядке, что он идёт после элементов, которые объявлены перед ним. И элементы, которые объявлены после него, идут после него.

Абсолютное позиционирование (absolute)
Положение абсолютного блока задаётся относительно страницы или относительно элемента с position: relative, в которой он вложен. Положение такого блока задаётся с помощью свойств top, right, bottom, left.
Элементы со статическим позиционированием игнорируют абсолютные блоки, которые как бы "вываливаются" из потока и живут своей собственной жизнью. Как будто существуют на своём собственном слое.

Фиксированное позиционирование (fixed)
Задаётся так же, как и абсолютное, но блок прикрепляется не к странице, а к экрану. То есть при прокрутке страницы он остаётся на своём месте.

Относительное позиционирование (position: relative)
Положение элемента устанавливается относительно его исходного места в потоке. Свойства left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения. А ещё оно работает как родитель, относительно которого можно задавать абсолютную позицию блокам, которые в него вложены.

Flexbox в CSS
CSS модуль для макетов с гибкими блоками

FlexBox состоит из Контейнера и его Дочерних элементов (items) (гибких элементов).

Главная ось - главное направление движения элементов внутри контейнера. Направление главной оси можно изменить с помощью свойства flex-direction. При смене осей, меняются только направления движения блоков внутри, а начало, конец и размер контейнера остаются прежними.

Начало и конец главной оси - элементы располагаются от начала и до конца контейнера.

Поперечная ось - направление движения элементов, когда они не умещаются в контейнер по направлению главной оси. Поперечная ось всегда перпендикулярна (⊥) главной.

Начало и конец поперечной оси - по поперечной оси заполняются ряды от начала и до конца контейнера. В каждом таком ряду располагаются элементы (читайте ниже).

Размер (главный и поперечный) - базовая величина по которой высчитывается ширина или высота внутренних элементов, если размер указан не точно (указан в процентах или не указан вообще, а элемент должен растянуться или сжаться).

Для включения flexbox, любому HTML элементу достаточно присвоить css свойство display:flex; или display:inline-flex;.

После включения flex свойства, внутри контейнера создаются две оси: главная и поперечная (перпендикулярная (⊥), кросс ось). Все вложенные элементы (первого уровня) выстраиваются по главной оси. По умолчанию главная ось горизонтальная и имеет направление слева направо (→), а кросс ось соответственно вертикальная и направлена сверху вниз (↓).

CSS свойства Flexbox

Для контейнера

display:
Включает flex свойство для элемента. Под это свойство попадает сам элемент и вложенные в него элементы: затрагиваются только потомки первого уровня - они станут элементами flex контейнера.

flex-direction:
Изменяет направление главной оси контейнера. Поперечная ось меняется соответственно.

flex-wrap:
Управляет переносом непомещающихся в контейнер элементов.










