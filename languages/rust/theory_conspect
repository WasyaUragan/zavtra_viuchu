========================
Инкапсуляция в Rust
Это принцип, при котором внутренняя реализация объекта скрывается, а взаимодействие с ним происходит через публичный интерфейс. В Rust инкапсуляция реализуется через систему модулей и модификаторы доступа (pub), что позволяет контролировать, какие данные и методы доступны извне.
========================
Области видимости в Rust
Это концепция, определяющая, где в коде переменные, функции, модули или другие сущности могут быть использованы или изменены. Области видимости ограничивают доступ к данным, предотвращая конфликты и ошибки, а также помогают управлять временем жизни переменных.
-------------------------
Переменные, объявленные внутри блока (например, внутри if, циклов, функций), видны только внутри этого блока.
Параметры и переменные функции существуют только в её теле.
-------------------------
Видимость элементов модуля контролируется ключевым словом pub (как обсуждалось ранее).
-------------------------
Переменная существует только в своей области видимости. При выходе из неё память автоматически освобождается (срабатывает drop).
========================
Переменная - это именованная область памяти, к которой мы имеем доступ из программы. Туда можно помещать значения и затем извлекать их.

Если переменная создаётся без присвоения значения, то это именуется объявлением.
При использовании объявления Rust требует для переменной аннотацию типа.

Инициализация переменной - это первое присвоение ей значения.

Наравне с объявлением, существует понятие определение, продемонстрированное в строке 'let age = 25;', когда происходит инициализация. При определении компилятор автоматически определяет тип значения, поэтому аннотации не требуется.

Не рекомендуется начинать с символа нижнего подчеркивания _, т.к. добавление подчеркивания в начале имени переменной приводит к её игнорированию компилятором, если она не используется.

В Rust переменные по умолчанию неизменяемы.
Для того чтобы сделать переменную изменяемой, необходимо указать ключевое слово 'mut' перед именем переменной.
Также значение одной переменной можно присвоить другой при условии, что они одинакового типа.

мы можем определять сразу несколько переменных:
fn main() {
    let (x, y) = (1, 2); // x = 1, y = 2
    let (mut a, mut b) = (3, 4); // a = 3, b = 4
}

В отличие от других языков, привязки в Rust должны быть инициализированы, прежде чем будут использованы:
fn main() {
    let x: i32;
    println!("The value of x is: {}", x); // ошибка
}
========================
Литерал (от лат. literal - буквальный) - постоянное (фиксированное) значение некоторого типа данных, прописанное в бинарном файле.
========================
// отличие метода от функции в rust

Метод — привязан к экземпляру структуры (struct) или перечисления (enum). Вызывается через точку: экземпляр.метод().
Функция — существует независимо от типов. Вызывается напрямую: функция().

Метод объявляется внутри блока impl для типа и принимает первым параметром self, &self или &mut self.
Функция объявляется вне блоков impl и не имеет доступа к self.

Метод может читать или изменять поля структуры через self.
Функция работает только с явно переданными аргументами.

Метод может быть статическим (без self), используемым для создания экземпляров или утилит.
Функция всегда вызывается по имени, а не через тип.
========================
Недопустимо помещать позиционные аргументы после именованных.
Как и в случае с позиционными, все предоставленные именованные аргументы должны использоваться.
========================
Ввод данных
------------------------
 создать изменяемую переменную строчного типа String для хранения пользовательского ввода:
 
use std::io; // Для подключения модулей, crate'ов или их частей используется ключевое слово use, после которого следует название источника импорта std, :: и требуемый элемент io. Равно std::io::stdin(); - если нет необходимости во включении какого-либо элемента для всего файла.
fn main() {
    println!("Пожалуйста, введите свою строку");

    let mut user_input = String::new(); //оператор видимости;

    let result = io::stdin()
        .read_line(&mut user_input)
        .expect("Не удалось прочитать ввод"); // вызываем метод read_line() у структуры Stdin, которую возвращает функция stdin(). read_line() считывает строку ввода из консоли, записывая её в переданную переменную.Символ амперсанд & указывает, что этот аргумент является ссылкой, которая предоставляет возможность нескольким частям вашего кода получить доступ к одному и тому же фрагменту данных без копирования их в память несколько раз.
    
    println!("Вы ввели: {:#?}", user_input);
    println!("result = {result}");
}

При нажатии клавиши ввода в данном случае SEND или Enter к строке h всегда добавляется ещё и символ новой строки, что приводит к считыванию двух символов: h и \n.

Но почему тогда println! печатает h, а не h\n ? Поскольку \n является управляющим символом, println! не экранирует его, поэтому он интерпретируется как специальный символ, обозначающий конец строки. Чтобы получить ожидаемый результат и вывести символ новой строки как \n, а не как перевод, мы можем его экранировать, используя соответствующий спецификатор формата :#?. 
========================

