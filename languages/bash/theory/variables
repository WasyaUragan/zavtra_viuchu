###
==============================
Переменные в bash - это область памяти
(обычно оперативной), в которой хранится значение.
==============================
Классификация переменных
------------------------------
Механизм установки
 - Пользовательские переменные
   filename="README.txt"; echo "$filename"
 - Зарезервированные (переменные оболочки) переменные
   echo "$PATH"
 - Специальные параметры
   echo "$?"

Область видимости
 - Переменные окружения (или глобальные)
   Выводятся утилитой env, запущенной без параметров.
   echo "$PATH"
 - Локальные переменные
   filename="README.txt"; echo "$filename"

Содержимое
 - Строка
   filename="README.txt"
 - Число
   declare -i number=10/2 ; echo "$number"
 - Индексируемый массив
   Хранит нумерованный список строк.
   cities=("London" "New York" "Berlin") ; 
   echo "${cities[1]}"
   cities[0]="London" ;
   cities[1]="New York";
   cities[2]="Berlin";
   echo "${cities[1]}"
 - Ассоциативный массив
   Структура данных, каждый элемент которой — это пара ключ-значение.
   Ключом и значением являются строки.
   declare -A cities=(["Alice"]="London" \
                      ["Bob"]="New York" \
                      ["Eve"]="Berlin" ) ;
   echo "${cities[Bob]}"

Возможность изменения
 - Константны
   readonly CONSTANT="ABC" ; echo "$CONSTANT"

   declare -r CONSTANT="ABC" ; echo "$CONSTANT"
 - Переменные
   filename="README.txt"
==============================
Чтобы избежать нежелательных подстановок Bash, заключайте все обращения к переменным в двойные кавычки “.

filename1="my file.txt"
cp "$filename1" ~
==============================
Cписок подстановок и порядок выполнения
------------------------------
 - Brace Expansion
   Подстановка фигурных скобок
   echo a{d,c,b}e
 - Tilde Expansion
   cd ∼
 - Parameter Expansion
   Подстановка параметров и переменных
   echo "$PATH"
 - Arithmetic Expansion
   Подстановка вместо арифметических выражений их результатов
   echo $((4+3))
 - Command Substitution
   Подстановка вместо команды её вывода
   echo $(< README.txt)
 - Process Substitution
   Подстановка вместо команды её вывода. В отличие от Command Substitution эта подстановка выполняется асинхронно²⁴⁹. Ввод и вывод команды привязаны к временному файлу.
   diff <(sort file1.txt) <(sort file2.txt)
 - Word Splitting
   Разделение аргументов командной строки на слова и передача их в качестве отдельных параметров.
   cp file1.txt file2.txt ∼
 - Filename Expansion (globbing)
   Подстановка имён файлов вместо шаблонов.
   rm ∼/delete/*
 - Quote Removal
   Удаление всех неэкранированных символов \, ‘ и “, которые не были получены в результате одной из предыдущих подстановок.
   cp "my file.txt" ∼
==============================
Знак $ перед именем переменной — это сокращенная форма подстановки переменных.
  ${filename}
------------------------------
Используйте полную форму, чтобы избежать неоднозначности.
  prefix="my"
  name="file.txt"
  cp "${prefix}_${name}" ~ или cp "$prefix"_"$name" ~
==============================
Mожно подставить некоторое значение по умолчанию.
  cp file.txt "${directory:-~}"
  При обработке этой команды Bash проверит, определена ли переменная directory и имеет ли она непустое значение. Если это так, выполнится обычная подстановка. В противном случае Bash подставит значение, следующее за символом минус -.
==============================
Задать значение по умолчанию можно несколькими способами.
------------------------------
  ${parameter:-word}

  Если переменная parameter не объявлена или имеет пустое значение будет подставлено значение по умолчанию word. В противном случае подставляется значение переменной.
------------------------------
  ${parameter:=word}

  Eсли переменная не объявлена или имеет пустое значение, ей будет присвоено значение по умолчанию. Затем она будет подставлена. В противном случае подставляется значение переменной. Переопределение позиционных и специальных параметров таким способом недопустимо.
------------------------------
  ${parameter:?word}

  Если переменная не объявлена или имеет пустое значение, значение по умолчанию будет выведено в стандартный поток ошибок. После этоговыполнение скрипта будет завершено с кодом возврата отличным от0. В противном случае подставляется значение переменной.
------------------------------
  ${parameter:+word}

  Если переменная не объявлена или имеет пустое значение, подстановки не будет. В противном случае подставляется значение по умолчанию.
==============================
Зарезервированные переменные Bash
------------------------------
Интерпретатор присваивает им значение по умолчанию. Значение некоторых
переменных оболочки можно изменить.

Зарезервированные переменные исполняют две функции:
1. Передача информации от командного интерпретатора в запускаемое им приложение.
2. Хранение текущего состояния самого интерпретатора.

Переменные оболочки делятся на две группы:
1. Переменные Bourne Shell.
2. Переменные Bash.

Первая группа унаследована из Bourne Shell и нужна Bash для POSIX-совместимости.
==============================
Зарезервированные переменные Bourne Shell:
------------------------------
HOME 
- Домашний каталог текущего пользователя.
------------------------------
IFS (Internal Field Separator) 
- Список следующих друг за другом символов-разделителей. Вводимые строки будут разделены этими символами на слова (например, при word splitting). По умолчанию разделители такие: пробел, табуляция, перевод строки ($' \t\n'). IFS активно используется в циклах, команде read, подстановке переменных и других операциях.

Основные варианты использования:

1. Разбиение строк на элементы

IFS=','  # Устанавливаем разделитель как запятую
str="apple,banana,cherry"
for fruit in $str; do
    echo "Фрукт: $fruit"
done

2. Чтение файлов построчно

# Читаем файл, игнорируя пробелы в начале/конце строк
while IFS= read -r line; do
    echo "Строка: $line"
done < file.txt

IFS= (пустое значение) сохраняет пробелы в начале/конце строки.

3. Обработка данных с нестандартными разделителями

# Разбиваем строку по двоеточию (например, /etc/passwd)
IFS=':' read -ra parts <<< "root:x:0:0:root:/root:/bin/bash"
echo "User: ${parts[0]}, Home: ${parts[5]}"

4. Безопасное чтение аргументов

# Сохраняем оригинальный IFS и восстанавливаем его после использования
OLD_IFS=$IFS
IFS=$'\n'  # Разделитель — только перевод строки
files=( $(ls) )
IFS=$OLD_IFS

5. Обработка CSV

data="John,Doe,30\nAlice,Smith,25"
while IFS=',' read -r firstname lastname age; do
    echo "$firstname $lastname: $age лет"
done <<< "$data"

Подводные камни:

 - Временное изменение IFS: Всегда сохраняйте оригинальное значение IFS, если меняете его глобально

 - Локальное изменение для команды:
   Изменение IFS только для команды `read`
   IFS=',' read -ra arr <<< "a,b,c"

 - Если IFS содержит пробел, Bash будет объединять последовательные пробелы в один разделитель.

 Советы:

 - Используйте $'\n' для разделения по строкам:
   IFS=$'\n' lines=($(cat file.txt))

 - Для обработки строк без разделителей установите IFS=$'\0' (нулевой байт), если поддерживается.

# Генерируем данные с нулевым разделителем
echo -e "file1.txt\0file2 with space.txt\0file3\nnewline.txt" > data.list
# Читаем данные по нулевому байту
while IFS= read -r -d $'\0' file; do
    echo "Найден файл: $file"
done < data.list

 - В циклах for и read изменение IFS влияет только на текущий контекст.
------------------------------
PATH

- Список путей, по которым интерпретатор ищет вызываемые утилиты и программы. Пути в списке разделены двоеточиями.

/home/zhuzhu/.cargo/bin:/home/zhuzhu/.local/bin:/home/zhuzhu/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/var/lib/snapd/snap/bin
------------------------------
PS1

- Приглашение командной строки. Может включать управляющие символы. Перед выводом на экран они заменятся на конкретные значения (например, имя текущего пользователя). Обычно она настраивается в файлах типа .bashrc или .bash_profile
==============================
Зарезервированные переменные Bash
==============================
BASH

- Полный путь до исполняемого файла Bash. Этот файл соответствует текущему процессу Bash.
------------------------------
BASHOPTS

- Список дополнительных опций текущего процесса Bash. Опции в списке разделены двоеточиями.
------------------------------
BASH_VERSION

- Версия запущенного Bash интерпретатора.
------------------------------
GROUPS

- Список групп, к которым относится текущий пользователь.
------------------------------
HISTCMD

- Номер текущей команды в истории команд.
------------------------------
HISTFILE

- Файл, в котором сохраняется история команд. По умолчанию это ∼/.bash_history.
------------------------------
HISTFILESIZE

- Максимально допустимое число строк в файле истории команд. Значение по умолчанию 500.
------------------------------
HISTSIZE

- Максимально допустимое число команд в файле истории команд. Значение по умолчанию 500.
------------------------------
HOSTNAME

- Имя текущего компьютера как узла вычислительной сети.
------------------------------
HOSTTYPE

- Строка с описанием аппаратной платформы, на которой запущен Bash.
------------------------------
LANG

- Региональные настройки²⁵⁴ пользовательского интерфейса. Некоторые из них переопределяются переменными LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_NUMERIC, LC_TYPE.
------------------------------
MACHTYPE

- Строка с описанием системы, на которой запущен Bash. Включает в себя информацию из переменных HOSTTYPE и OSTYPE.
------------------------------
OLDPWD

- Предыдущий рабочий каталог, который устанавливала встроенная команда cd.
------------------------------
OSTYPE

- Строка с описанием ОС, на которой запущен Bash.
------------------------------
POSIXLY_CORRECT

- Если эта переменная определена, Bash работает в режиме POSIX-совместимости
------------------------------
PWD

- Текущий каталог, который установила встроенная команда cd.
------------------------------
RANDOM

- Каждый раз при чтении этой переменной возвращается случайное число от 0 до 32767. При записи переменной назначается инициализирующее число (seed) для генератора псевдослучайных чисел.
------------------------------
SECONDS

- Количество секунд, прошедших с момента запуска текущего процесса Bash.
------------------------------
SHELL

- Полный путь к исполняемому файлу командного интерпретатора для текущего пользователя.
------------------------------
SHELLOPTS

- Список дополнительных опций²⁵⁸ комндного интерпретатора. Опции в списке разделены двоеточиями.
------------------------------
SHLVL

- Уровень вложенности текущего экземпляра Bash. Эта переменная увеличивается на единицу каждый раз при запуске Bash из командного интерпретатора.
------------------------------
UID

- Идентификатор текущего пользователя.
------------------------------
Зарезервированные переменные делятся на три группы в зависимости от допустимых над ними действий:

1. При запуске интерпретатор назначает переменной значение. В течении всей сессии оно остаётся неизменным. Пользователь может его прочитать, но не изменить. Примеры: BASHOPTS, GROUPS, SHELLOPTS, UID.

2. При запуске интерпретатор назначает переменной значение по умолчанию. Оно меняется в результате выполнения пользователем команд или иных событий. Значение некоторых переменных можно переобъявить явно, но это может нарушить работу интерпретатора. Примеры: HISTCMD, OLDPWD, PWD, SECONDS, SHLVL.

3. При запуске интерпретатор назначает переменной значение по умолчанию. Единственный способ его изменить — это переобъявить. Примеры: HISTFILESIZE, HISTSIZE
==============================
Специальные параметры Bash
------------------------------
- назначаются интерпретатором, как и переменные оболочки. Некоторые параметры хранят состояние запущенного экземпляра Bash (например, PID). Другие нужны для передачи параметров командной строки в вызываемые приложения и чтения их кода возврата. Все позиционные параметры относятся к специальным.
------------------------------
$*  - Содержит все позиционные параметры, переданные в скрипт. Параметры начинаются не с нулевого ($0), а с первого ($1). Без двойных кавычек ($*),каждый позиционный параметр подставляется как отдельное слово. С двойными кавычками ("$*"), Bash подставляет одно слово, содержащее все параметры. Они разделяются первым символом зарезервированной переменной IFS.

$@  - Массив со всеми позиционными параметрами, переданными в скрипт. Параметры начинаются с первого ($1). Без двойных кавычек ($@), Bash обрабатывает каждый элемент массива как строку без кавычек. В этом случе выполняется word splitting. С Двойным кавычками (“$@”), Bash обрабатывает каждый элемент массива как строку с кавычками. Wird splitting не происходит.

$#  - Число позиционных параметров, переданных в скрипт.

$1, $2… - Содержит значение соответствующего позиционного параметра. $1 соответствует первому параметру, $2 — второму и т.д. Номера указываются в десятичной системе.

$?  - Код возврата последней выполненной команды в активном режиме (foreground). Если команды выполнялись в конвейере, параметр хранит код возврата последней из них.

$-  - Содержит опции текущего экземпляра интерпретатора.

$$  - Идентификатор процесса текущего экземпляра интерпретатора. При подстановке в subshell, возвращает PID родительского процесса.

$!  - Идентификатор процесса PID последней команды, запущенной в фоновом режиме.

$0  - Имя текущего командного интерпретатора или выполняемого в данный момент скрипта.
------------------------------
Специальные параметры нельзя менять непосредственно. Например, следующее перезапись параметра $1 не сработает:

1="new value"

Позиционные параметры можно изменять командой set. Она перезаписывает не один параметр, а сразу все.
Форма вызова set в этом случае следующая:

set -- НОВОЕ_ЗНАЧЕНИЕ_$1 НОВОЕ_ЗНАЧЕНИЕ_$2 НОВОЕ_ЗНАЧЕНИЕ_$3...

Что делать, если нужно изменить только один параметр? Предположим, ваш скрипт вызывается с четырьмя параметрами. Например, так:

./my_script.sh arg1 arg2 arg3 arg4

Заменим третий параметр arg3 на значение new:

set -- "${@:1:2}" "new" "${@:4}"

Первый аргумент set — подстановка первых двух элементов из массива $@. Второй аргумент — новое значение третьего параметра. Дальше подставляются все параметры, начиная с четвертого.

Все специальные параметры из таблицы 3-6 доступны в режиме POSIX-совместимости.
==============================
Переменные окружения
==============================
Область видимости — это часть программы или системы, в которой имя переменной остаётся связанным с её значением. Другими словами конвертировать имя переменной в её адрес можно только в области видимости этой переменной. За пределами области видимости то же самое имя может быть связано с другой переменной.

Область видимости называется глобальной (global scope), если распространяется на всю систему. То есть переменные этой области видимости доступны из любой части программы или системы.

Все зарезервированные переменные Bash находятся в глобальной области видимости. Переменные в этой области видимости называются переменными окружения (environment variables). Получается, что все зарезервированные переменные являются переменными окружения. Пользовательские переменные также можно объявлять в глобальной области видимости. Тогда они станут переменными окружения.

Предположим, что один процесс порождает дочерний процесс. В этом случае дочерний процесс копирует все переменные окружения родителя. Таким образом все утилиты и приложения, запущенные из командного интерпретатора, наследуют его переменные окружения. Так глобальные настройки передаются во все запускаемые пользователем программы.

Дочерние процессы могут изменять свои переменные окружения. В результате порождённые ими процессы унаследуют эти изменения. Однако, это никак не отразится на соответствующих переменных родительского процесса.
------------------------------
Чтобы объявить переменную окружения:

export BROWSER_PATH="/opt/firefox/bin"
------------------------------
Переменную можно сначала объявить, а потом поместить в глобальную область видимости:

BROWSER_PATH="/opt/firefox/bin"
export BROWSER_PATH
------------------------------
Переменные окружения можно объявлять и переопределять для каждого запускаемого приложения отдельно. Для этого в команде вызова программы перечислите их имена и значения через пробел:

MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox

Такое решение работает для интерпретатора Bash. Для других интерпретаторов (например, Bourne Shell) придётся использовать утилиту env.

env MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox
------------------------------
Команда export и утилита env выводят одно и то же, если вызвать их без параметров. Предпочтительней использовать export. Во-первых, вывод команды отсортирован. Во-вторых, все значения переменных заключены в двойные кавычки. Это убережёт вас от ошибки, если в значении переменной встретится перевод строки.
------------------------------
Исторически сложилось так, что имена переменных окружения пишутся буквами в верхнем регистре. Поэтому давать имена локальным переменным в нижнем регистре считается хорошей практикой.
==============================
Локальные переменные
==============================
Она будет доступна только в текущем экземпляре интерпретатора, локальная переменная имеет ограниченную область видимости (local scope). При этом никакие дочерние процессы (кроме subshell) её не наследуют.
------------------------------
После объявления локальной переменной она попадает в список переменных оболочки
(shell variables). К ним относятся все локальные переменные и переменные окружения,
доступные в текущем экземпляре интерпретатора.
==============================
Содержимое переменной
==============================
Типы переменных
==============================
Bash использует динамическую типизацию, что означает, что типы переменных определяются во время выполнения, а не на этапе компиляции (как в статически типизированных языках). Вот ключевые особенности:

 - Переменные не имеют явного типа: Все переменные по умолчанию хранят данные как строки.
 - Тип определяется контекстом: В зависимости от операции (арифметика, сравнение, строковые операции) Bash интерпретирует переменные как числа, строки или другие типы.
 - Гибкость: Можно легко менять «тип» переменной в процессе выполнения скрипта.
------------------------------
Bash не поддерживает статическую типизацию. Однако с помощью команды declare можно добавить атрибуты переменным, что частично имитирует контроль типов:

Информация о переменных / конкретной переменной
declare -p / declare -p variable
------------------------------
Информация о функциях / конкретной функции
declare -f / declare -f func_name
------------------------------
declare -a variable
Объявленная переменная является индексируемым массивом. Элементы такого массива доступны по целочисленным номерам.
------------------------------
declare -A variable
Объявленная переменная является ассоциативным массивом. Каждому элементу такого массива соответствует ключ-строка.

Окружение процессов поддерживает только строки вида KEY=VALUE.
Сложные структуры данных (массивы, ассоциативные массивы) не могут быть переданы через окружение.

Что делать, если нужно передать данные?
Используйте строки или файлы для обмена данными между процессами:

declare -A user=([name]="Alice" [age]=30)
# Преобразуем массив в строку
user_str=$(declare -p user)
# Передаем строку в дочерний процесс
bash -c "eval $user_str; echo Имя: ${user[name]}"
------------------------------
declare -g variable
Объявление переменной в глобальной области видимости скрипта. При этом
переменная не попадает в окружение.
------------------------------
declare -i 
Объявление целочисленной переменной. Присваиваемое ей значение обрабатывается как арифметическое выражение.
------------------------------
declare -r
Объявление константы. После объявления ей нельзя присвоить другое значение.
------------------------------
declare -x
Объявление переменной окружения.
------------------------------
Для удаления переменной любого типа, кроме константы, используйте встроенную команду unset.
==============================
При подстановке переменной, если обязательно нужны ковычки, можно использовать eval:

ls_command="ls -l"
eval "$ls_command" равно $ls_command
==============================