###
В Bourne Shell есть только скалярные переменные. В Bash появились два новых составных типа: индексируемый массив и ассоциативный массив.

Индексируемый массив представляет собой пронумерованный набор строк. В нём каждой строке соответствует порядковый номер. Массивы этого типа хранятся в памяти в виде связанного списка. Связанный список — это структура данных, состоящая из узлов. Каждый узел содержит данные (в нашем случае строку) и адрес в памяти следующего узла.

Ассоциативный массив устроен сложнее. Он представляет собой набор элементов. Каждый элемент состоит из двух строк. Первая из них называется ключом, а вторая — значением. Чтобы прочитать или записать строку в массив, нужно указать соответствующий ей ключ. Точно так же в индексируемом массиве для доступа к строке указывается её порядковый номер. Очевидно, что под одним номером может храниться только одна строка. Аналогично один ключ в ассоциативном массиве соответствует только одной строке. В памяти такой массив хранится в виде хеш-таблицы.

==============================
Индексируемые массивы
==============================
У строкового типа есть серьёзное ограничение. При записи в скалярную переменную какого-то значения, логически получается один элемент. Например, вы сохраняете в переменную с именем files список файлов. Элементы списка разделены пробелами. В результате files хранит одну строку с точки зрения Bash.

Как мы выяснили, стандарт POSIX разрешает любые символы в именах файлов, кроме нуль-терминатора (NUL). NUL означает конец имени файла. Этот же самый символ в
Bash означает конец строки. Поэтому строковая переменная может содержать NUL не в произвольном месте, а только в конце. Получается, у вас нет надёжного способа разделить имена файлов в списке. NUL использовать нельзя. Любой другой символ-разделитель может встретиться в этих именах.

Именно проблема разделителя мешает надёжно обработать вывод утилиты ls. Утилита find позволяет разделять элементы своего вывода с помощью NUL, а ls - нет. Никакой символ кроме NUL не будет надёжным разделителем.

Массивы добавлены в Bash для решения этой проблемы. Массив хранит список отдельных элементов. Прочитать их в исходном виде не составляет труда. Поэтому вместо присваивания переменной вывода утилиты ls, используйте массив.
Например:

declare -a files=(Documents/*.txt)

Инициализацией массива называется определение его элементов. Массив можно инициализировать при объявлении или после. В примере выше инициализация files происходит при объявлении.

Bash способен вывести тип переменной самостоятельно. Этот механизм работает, когда вы присваиваете значение переменной при объявлении. В зависимости от значения Bash добавляет соответствующий атрибут. В таком случае команду declare можно опустить.
Например, наш массив files можно объявить без declare:

files=(Documents/*.txt)

Предположим, что элементы массива получаются не в результате подстановки, а известны заранее. В этом случае их можно задать явно при объявлении.
Это будет выглядеть так:

files=("/usr/share/README" "/usr/share/README.md" "/usr/share/README")

Элементы массива можно читать из значений других переменных.
Изменение этих переменных после объявления массива, никак не отразится на его содержимом.
Например:

bash_doc="/usr/share/doc/bash/README"
flex_doc="/usr/share/doc/flex/README.md"
xz_doc="/usr/share/doc/xz/README"
files=("$bash_doc" "$flex_doc" "$xz_doc")

При объявлении массива для каждого его элемента можно явно указать индекс. Например:

files=([0]="$bash_doc" [1]="$flex_doc" [5]="/usr/share/README")

Вместо инициализации всего массива за раз, можно определять его элементы по отдельности.
Например, так:

files[0]="$bash_doc"
files[1]="$flex_doc"
files[5]="/usr/share/README"

В последних двух объявлениях массива files нумерация индексов идёт не по порядку. Это не ошибка. Bash допускает массивы с пропусками (sparse arrays).

Иногда бывает полезно вывести только индексы элементов. Для этого в подстановке добавьте восклицательный знак перед именем массива.
Например:

$ echo "${!files[@]}"
0 1 5

При подстановке индекс элемента можно рассчитать по формуле. Просто укажите в квадратных скобках арифметическое выражение для его вычисления. 
Например, так:

echo "${files[4+1]}"
files[4+1]="/usr/share/doc/xz/README"

В арифметическом выражении можно использовать переменные. Причём они могут быть объявлены и как целочисленные, и как строковые.
Например:

i=4
echo "${files[i+1]}"
files[i+1]="/usr/share/doc/xz/README"

Следующие подряд элементы можно подставить одной командой. Для этого после двоеточия укажите стартовый индекс и число элементов.
Например, так:

$ echo "${files[@]:1:2}"
/usr/share/README.md /usr/share/README

Bash, начиная с версии 4, предоставляет встроенную команду readarray (также известную как mapfile). Она читает содержимое текстового файла в массив. Рассмотрим, как её использовать.

Предположим, что у нас есть файл с именем names.txt. Его содержимое такое:

Alice
Bob
Eve
Mallory

Создадим массив со строками из этого файла. Для этого достаточно выполнить следующую команду:

readarray -t names_array < names.txt

Предположим, что массив files содержит список имён файлов. Вам
нужно скопировать первый файл в списке.
cp "${files[0]}" ~/Documents

Для подстановки всех элементов используйте символ @ вместо индекса.
cp "${files[@]}" ~/Documents

Чтобы получить размер массива, поставьте символ решётка # перед его именем.
echo "${#files[@]}"

Чтобы удалить элемент массива, используйте встроенную команду unset.
unset 'files[3]'

С помощью команды unset можно также очистить весь массив:
unset files
==============================
Ассоциативные массивы
==============================
Мы рассмотрели индексируемые массивы. В них элементами являются строки, а индексами — целые положительные числа. Массивы этого типа по указанному индексу возвращают соответствующую ему строку.

В Bash версии 4 добавили ассоциативные массивы. В них индексы — это не числа, а строки.
Такая строка-индекс называется ключом (key). Ассоциативный массив по указанной строке-индексу возвращает соответствующую ей строку-значение.

Элементы массива можно задавать по отдельности. Например, так:

declare -A contacts
contacts["Alice"]="alice@gmail.com"
contacts["Bob"]="(697) 955-5984"
contacts["Eve"]="(245) 317-0117"
contacts["Mallory"]="mallory@hotmail.com"

Чтобы вывести список всех ключей, поставьте восклицательный знак ! перед именем массива.

Например:
echo "${!contacts[@]}"
Bob Mallory Alice Eve

Размер массива выводится с помощью символа решётка #
echo "${#contacts[@]}"
==============================
Конструкция ${!array_name[*]} возвращает все ключи (индексы) массива:

 - Для обычных массивов - числовые индексы (0, 1, 2...)
 - Для ассоциативных массивов - строковые ключи

------------------------------
Основные варианты использования ! с массивами:

Конструкция     Результат
${!array[@]}	Все ключи массива
${!array[*]}	Все ключи (как одна строка)
${array[@]}	    Все значения массива
${array[*]}	    Все значения (как одна строка)
${!prefix*}	    Имена переменных с префиксом
------------------------------
Для получения количества элементов:

count=${#spisok_otvetov[@]}
==============================