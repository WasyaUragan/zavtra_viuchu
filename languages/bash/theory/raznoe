###
==============================
Код возврата последней выполненной команды всегда сохраняется в переменной
окружения Bash с именем '?'. Для вывода её значения используйте команду 'echo $?'.
==============================
Команда переименовывает все файлы с расширением .txt в .md в текущей директории и подкаталогах. 

mv "document.txt" "${1%.txt}.md"

% — оператор, удаляющий кратчайшее совпадение с указанным шаблоном (.txt) с конца строки.
==============================
Нулевой байт (null byte, \0) — это специальный символ с ASCII-кодом 0, который используется в программировании и Unix-системах как маркер конца строки или разделитель данных. В контексте Bash и обработки текста он часто применяется для безопасной работы с именами файлов и строками, содержащими пробелы, переводы строк и другие "проблемные" символы.

Не все утилиты поддерживают \0:

 - find с -print0 и xargs с -0 — поддерживают.
 - Старые версии Bash или некоторые команды могут не работать с нулевым байтом.
==============================
Управляющие символы в Bash — это специальные символы, которые интерпретируются оболочкой (Bash) особым образом. Они используются для управления выполнением команд, перенаправления ввода/вывода, группировки операций и других задач.
------------------------------
Вот основные категории и примеры:
------------------------------
1. Разделители команд

Позволяют выполнять несколько команд в одной строке:

; — выполнить команды последовательно:
echo "Hello"; echo "World"  # Вывод: Hello → World

& — запустить команду в фоновом режиме:
sleep 10 &  # Запуск sleep в фоне

| (pipe) — передать вывод одной команды на вход другой:
ls | grep ".txt"  # Вывести список файлов .txt
------------------------------
2. Логические операторы (&& и ||)
------------------------------
3. Перенаправление ввода/вывода (>, >>, <)
------------------------------
4. Подстановки (*,?)
------------------------------
5. Управление процессами

sleep 100 &
echo "PID: $!"  # Выведет PID процесса sleep
------------------------------
6. Экранирование символов

   \ — экранирует следующий символ:
   echo "Цена: \$100"  # Вывод: Цена: $100

   ' ' (одинарные кавычки) — отключают интерпретацию всех символов внутри:
   echo '$USER *'  # Вывод: $USER *

   " " (двойные кавычки) — интерпретируют переменные, но экранируют управляющие символы:
   echo "User: $USER"  # Вывод: User: username
------------------------------
7. Группировка команд
  
   () — выполнить команды в подоboлочке (subshell):
   (cd /tmp && ls)  # Переход в /tmp и вывод списка файлов (не влияет на текущую сессию)

   {} — выполнить команды в текущей оболочке:
   { echo "Start"; ls; } > log.txt  # Группировка с перенаправлением вывода.
==============================
Subshell (подоболочка) в Bash — это дочерний процесс оболочки, который запускается внутри текущей сессии Bash. Он наследует переменные окружения, файловые дескрипторы и другие настройки родительской оболочки, но любые изменения, сделанные в subshell (например, изменение переменных или текущей директории), не влияют на родительский процесс.
------------------------------
Subshell автоматически запускается в следующих случаях:

1. Команды в круглых скобках ( ):

(a=10; echo "Subshell: a = $a") 
# a=10 только внутри subshell
echo "Parent: a = $a"
# Вне subshell переменная a не определена.

2. Конвейеры (pipes) |:

echo "hello" | read message
# read выполняется в subshell
echo "Message: $message"
# Выведет пустоту (message не сохранится).

3. Фоновые процессы &:

sleep 10 &  # Запуск sleep в фоне (subshell).

4. Команды, обернутые в $( ) или ``:

files=$(ls)  # Результат ls сохраняется в переменную files через subshell.

5. Некоторые встроенные команды, например coproc.

Coproc — команда в Linux, которая позволяет создавать со-процесс — фоновый процесс, который работает параллельно с основной командной оболочкой и взаимодействует с ней через файловые дескрипторы. 
Это полезно в сценариях, где нужно запустить команду в фоновом режиме, но при этом взаимодействовать с ней. Со-процесс может асинхронно отправлять и получать данные, что позволяет одновременно выполнять несколько задач.
------------------------------
Subshell vs Sourcing

source script.sh — выполняется в текущей оболочке (изменения переменных сохраняются).

./script.sh — запускается в отдельном процессе (subshell).
==============================
bash -c 'echo "$filename"'

В опции -c передаётся команда, которая выполнится дочерним процессом Bash. Аналогичный вызов Bash происходит неявно при запуске скрипта из командного интерпретатора.

Обратите внимание на одинарные кавычки ‘, в которые мы поместили вызов echo. Они отключают все подстановки для строки в них. У двойных кавычек поведение отличается. Они разрешают только подстановку команд и параметров.
==============================
Чтобы передать строку в файл с переносами строк после каждого слова, используйте echo -e или printf.

1) echo -e "one\ndva\nthree\nchetire" > test_array
     -e — активирует интерпретацию escape-последовательностей (включая \n)

2) printf "one\ndva\nthree\nchetire\n" > test_array
     printf по умолчанию поддерживает \n.
     Добавлен последний \n, чтобы файл завершался переносом строки.

3) Если слова хранятся в переменной или массиве:

words=("one" "dva" "three" "chetire")
printf "%s\n" "${words[@]}" > test_array

4) for word in one dva three chetire; do
    echo "$word" >> test_array
   done

5) echo "one"$'\n'"dva"$'\n'"three"$'\n'"chetire" > test_array
==============================
# to generate a random number between 1 and 10 (inclusive):

echo $((1 + $RANDOM % 10))

The actual generator is in variables.c, the function brand().
------------------------------
If you're doing something that requires serious random numbers you can use /dev/random or /dev/urandom:

echo $(( $(od -An -N4 -tu4 < /dev/urandom) % 100 + 1 ))

Почему urandom, а не random?
/dev/random может блокировать выполнение при нехватке энтропии, /dev/urandom безопаснее для скриптов.
------------------------------
shuf -i 1-100 -n 1
==============================
Если необходимо использовать больше 9 параметров для скрипта, то начиная с десятой переменной, число, стоящее после знака $, необходимо заключать в квадратные скобки (без внутренних пробелов):

echo "Десятый параметр равен $[10]"
==============================
Обработка неизветсного числа параметров

Для начала рассмотрим один из часто используемых инструментов при работе с параметрами Bash — команду shift.

Её прямое назначение заключается в сдвиге параметров на одну позицию влево. Таким образом, значение из переменной $3 переместится в $2, а из $2 — в $1. Но из $1 значение просто отбросится и не сместится в $0, так как там неизменно хранится название запущенной программы.

Эта команда является эффективным способом обработки всех параметров, переданных сценарию, особенно, когда нельзя заранее узнать их количество. Достаточно лишь обработать $1, сделать сдвиг и повторить процедуру.

count=1

while [ -n "$1" ]
do
  echo "Параметр №$count = $1"
  count=$[ $count + 1 ]
  shift
done

# сместить ряд параметров на 2 (две) позиции
shift 2

На заметку: при использовании shift нужно быть осторожным, ведь сдвинутые за пределы $1 параметры не восстанавливаются в период работы программы.
==============================
${var,,} преобразует строку в нижний регистр (bash 4.0+)
==============================
Bash Heredoc
------------------------------
В Bash и других оболочках (например, Zsh) here-document (heredoc) — это форма перенаправления, которая позволяет передавать несколько строк ввода команде.

[КОМАНДА] <<[-] РАЗДЕЛИТЕЛЬ
  HERE-DOCUMENT
РАЗДЕЛИТЕЛЬ

Первая строка начинается с необязательной команды, оператора << и идентификатора-разделителя.
Любая строка может быть разделителем; часто используют EOF или END.
Если разделитель не в кавычках (' или "), выполняется подстановка переменных, подстановка команд и т.д.
Использование <<- заставляет оболочку удалять начальные табуляции из here-документа (пробелы не удаляются).
Последняя строка должна содержать только разделитель (без начальных пробелов или символов в конце).

Heredoc чаще всего используется с cat.
------------------------------
Вывод с переменными

cat << EOF
Текущий рабочий каталог: $PWD
Вы вошли как: $(whoami)
EOF
------------------------------
Без подстановки переменных

Кавычки вокруг разделителя отключают подстановку:

cat << "EOF"
Текущий рабочий каталог: $PWD
Вы вошли как: $(whoami)
EOF
------------------------------
Запись в переменную

DB_USER=db_user
DB_NAME=db_name
DB_PASSWORD=db_pass

COMMAND=$(cat << BASH
mysql -u "$DB_USER" -p"$DB_PASSWORD" -e "USE $DB_NAME;" 2>/dev/null
if ! \$?; then
	mysql -u "$DB_USER" -p"$DB_PASSWORD" -e "CREATE DATABASE $DB_NAME;"
fi
BASH
)

echo "$COMMAND"
------------------------------
Запись в файл

Вместо вывода на экран вы можете перенаправить его в файл, используя операторы >, >>. Если файл file.txt не существует, он будет создан.

cat << EOF > file.txt
Текущий рабочий каталог: $PWD
Вы вошли как: $(whoami)
EOF
------------------------------
Ввод heredoc также может быть направлен в конвейер (пайп, |). В следующем примере команда sed заменит все вхождения символа l на e:

cat <<'EOF' | sed 's/l/e/g'
Hello
World
EOF

Запись данных из конвейера в файл

cat <<'EOF' | sed 's/l/e/g' > file.txt
Hello
World
EOF
------------------------------
Использование heredoc с SSH

Использование Heredoc — один из самых удобных и простых способов выполнить несколько команд на удалённой системе через SSH.

При использовании разделителя без кавычек убедитесь, что вы экранируете все переменные, команды и специальные символы, иначе они будут интерполированы локально:

ssh -T user@host.com << EOF
echo "Локальный рабочий каталог: $PWD"
echo "Удалённый рабочий каталог: \$PWD"
EOF
==============================