==============================
Операторы цикла
==============================
Оператор цикла многократно повторяет один и тот же блок команд. Однократное выполнение этого блока называется итерацией цикла. На каждой итерации проверяется условие цикла. В зависимости от результата, цикл продолжается или прекращается.
==============================
Холостой цикл
==============================
Холостой цикл — реализация ожидания в компьютерной программе, в котором проверка определённого условия осуществляется в бесконечном цикле. Выход из бесконечного цикла происходит только при удовлетворении проверяемого условия.

Также холостой цикл может использоваться для создания произвольной задержки выполнения программы.

В большинстве случаев холостой цикл считается антипаттерном, которого нужно избегать путём реорганизации кода или использование иного подхода к разработке (асинхронное выполнение, событийно-ориентированное программирование и т. п.).
------------------------------
Примеры холостых циклов в Bash:

1. Классический вариант с while true или ":"

# while :; do (: - встроенная команда, которая всегда возвращает true)
while true; do
    echo "Цикл выполняется..."
    sleep 1
done

У true есть симметричная команда false. Она всегда возвращает единицу, то есть ложь.

2. Через for без условий

for ((;;)); do
    echo "Вечный цикл"
    sleep 1
done
------------------------------
Для чего применяются холостые циклы?

1. Демоны и сервисы
Программы, работающие в фоновом режиме (например, сетевые серверы):

while true; do
    # Ожидание подключений
    nc -l -p 8080 -c "echo 'HTTP/1.1 200 OK\n\nHello World'"
done

2. Мониторинг в реальном времени
Постоянная проверка состояния системы:

while :; do
    clear
    echo "===== Мониторинг ====="
    top -bn1 | head -5
    sleep 2
done

3. Обработка событий
Чтение логов или файловых изменений:

tail -f /var/log/syslog | while read line; do
    if [[ "$line" =~ "ERROR" ]]; then
        echo "Найдена ошибка: $line"
    fi
done

4. Повторные попытки
Повтор операции до успеха:

while true; do
    if ping -c1 google.com; then
        echo "Сеть доступна!"
        break
    else
        echo "Повторная попытка через 5 сек..."
        sleep 5
    fi
done

5. Интерактивные интерфейсы
Меню управления:

while :; do
    echo "1. Запустить"
    echo "2. Остановить"
    echo "3. Выход"
    read -p "Выберите: " choice
    
    case $choice in
        1) start_service;;
        2) stop_service;;
        3) break;;
        *) echo "Неверный вариант";;
    esac
    sleep 1
done

6. Ожидание условий
Ожидание доступности ресурса:

while true; do
    if [[ -f /tmp/ready.flag ]]; then
        echo "Файл появился!"
        break
    fi
    sleep 1
done
------------------------------
Как прервать холостой цикл?

1. Изнутри: break или exit

2. Извне:
   - Ctrl+C (отправляет SIGINT)
   - kill <PID> (сигнал TERM)
------------------------------
Важные нюансы

Всегда добавляйте задержку в длительные циклы, без sleep цикл может потреблять 100% ядра CPU.

Холостой цикл — мощный инструмент для задач, требующих постоянной активности, но требует аккуратного использования чтобы избежать проблем с производительностью.
------------------------------
Альтернативы

Для системных демонов лучше использовать специализированные инструменты:

- systemd для сервисов
- inotifywait для отслеживания файлов
- cron для периодических задач
==============================
Оператор while
==============================
while УСЛОВИЕ
do
ДЕЙСТВИЕ
done
------------------------------
while УСЛОВИЕ; do ДЕЙСТВИЕ; done
------------------------------
Используйте цикл while, когда количество итераций заранее неизвестно. Например, при активном ожидании какого-то события.

while ! ping -c 1 -W 1 google.com &> /dev/null
do
  sleep 1
done

echo "Сервер google.com доступен"
------------------------------
У конструкции while есть альтернативная форма until. В ней ДЕЙСТВИЕ выполняется до тех пор, пока УСЛОВИЕ ложно. То есть цикл выполняется, пока УСЛОВИЕ возвращает отличный от нуля код. С помощью формы until можно инвертировать условие while.

until УСЛОВИЕ; do ДЕЙСТВИЕ; done

Старайтесь составлять условия без отрицаний. Отрицания усложняют чтение кода.
------------------------------
При работе с Bash часто возникает задача циклического выполнения команды. Для этого есть специальная утилита watch.

watch -n 2 "df -hT"

Опция -n утилиты watch задаёт интервал между вызовами команды. Команда для исполнения указывается после всех опций.

Опция watch -d подсвечивает разницу в выводе команды, выполненной на текущей итерации и на прошлой. Благодаря этому, легче отследить произошедшие изменения.
------------------------------
Для чтения строк файла - read.

Она читает строку из стандартного потока ввода. Затем сохраняет строку в переменную. Имя переменной передаётся в команду как параметр.

Если вызвать read без параметров, введённая строка сохранится в зарезервированной переменной REPLY.

Команда read читает введённую пользователем строку. При этом read удаляет из строки символы обратного слэша . Они экранируют специальные символы. Поэтому read считает слэши ненужными. Чтобы отключить эту функцию, используйте опцию -r. В противном случае некоторые символы из ввода могут потеряться.

Команде read можно передать на вход несколько имён переменных. В этом случае введённый пользователем текст разделится на части. Разделителями будут символы из зарезервированной переменной IFS. По умолчанию это пробел, знак табуляции и перевод строки.

IFS=$',' read -r path file

Команда read читает данные со стандартного потока ввода. Это значит, что ей на вход можно перенаправить содержимое файла.

Чтобы цикл while последовательно прошёл по всем строкам файла, запишем его в следующей форме:

while УСЛОВИЕ
do
  ДЕЙСТВИЕ
done < ФАЙЛ

Чтобы обработать ввод пользователя с клавиатуры, в качестве файла укажите /dev/tty. Тогда цикл будет обрабатывать ввод до тех пор, пока пользователь не нажмёт сочетание клавиш Ctrl+D.
==============================
Оператор for
==============================
Используйте его, когда количество итераций известно заранее.

У оператора for есть две формы. Первая нужна для последовательной обработки слов в строке. Во второй форме условием цикла выступает арифметическое выражение.
==============================
Первая форма for

for ПЕРЕМЕННАЯ in СТРОКА
do
  ДЕЙСТВИЕ
done

for ПЕРЕМЕННАЯ in СТРОКА; do ДЕЙСТВИЕ; done

Перед первой итерацией цикла Bash выполнит все подстановки в условии конструкции for. Что это значит? Предположим, что вместо СТРОКИ вы указали команду. Тогда перед началом цикла команда выполнится и её вывод заменит СТРОКУ. Если указать шаблон — он будет развёрнут.

Дальше СТРОКА разделяется на слова. Разделители читаются из переменной IFS. Затем выполняется первая итерация цикла. Во время итерации первое слово из СТРОКИ будет доступно в теле цикла как значение ПЕРЕМЕННОЙ. На второй итерации в ПЕРЕМЕННУЮ запишется второе слово СТРОКИ и т.д. Цикл завершится после прохода по всем словам СТРОКИ.

for word in $1
do
  echo "$word"
done

Обратите внимание, что позиционный параметр $1 не надо заключать в кавычки. Если это сделать, не сработает word splitting. Входная строка не разделится на слова. Тогда тело цикла выполнится один раз. При этом в переменную word запишется вся входная строка.

Передаваемую в скрипт строку надо заключить в кавычки. Тогда она целиком попадёт в позиционный параметр $1. Например:

./for-string.sh "this is a string"

Проблему кавычек при передаче строки в скрипт можно решить. Замените в условии цикла позиционный параметр $1 на $@. Получится такая конструкция for:

for word in $@
do
  echo "$word"
done

Теперь сработают оба варианта вызова скрипта:

./for-string.sh this is a string
./for-string.sh "this is a string"
------------------------------
У условия цикла for есть краткая форма. Она перебирает все входные параметры скрипта. Мы записали условие цикла так:

for word in $@

Тот же самый результат даст следующее условие:

for word
do
  echo "$word"
done

Мы просто отбросили “in $@” в условии. Поведение цикла от этого не изменилось.
------------------------------
Скрипт для обработки первых трёх элементов массива:

array=(Alice Bob Eve Mallory)

for element in "${array[@]:0:2}"
do
  echo "$element"
done

равно 

array=(Alice Bob Eve Mallory)

# for i in {0..2}
for i in 0 1 2
do
  echo "${array[i]}"
done

Не используйте индексы элементов при обработке массивов с пропусками. Вместо этого подставляйте нужные элементы массива в условии цикла, как в листингах 3-25 и 3-26.
------------------------------
Скрипт для вывода типов файлов:

Не забывайте про двойные кавычки при подстановке переменной filename. Это предотвратит word splitting в именах файлов с пробелами.

В Bash начиная с версии 4 шаблоны позволяют обходить каталоги рекурсивно (**). Чтобы это сработало, включите опцию интерпретатора globstar с помощью команды shopt.

Листинг 3-27

shopt -s globstar

for filename in ~/**/*
do
  file "$filename"
done

Скрипт можно заменить следующим вызовом утилиты find:

find . -maxdepth 1 -exec file {} \;

Такое решение эффективнее, чем цикл for. Оно компактнее и работает быстрее из-за меньшего числа операций.

Когда стоит обрабатывать файлы в цикле for, а когда утилитой find? Используйте find, когда файлы можно обработать одной короткой командой. Если для обработки нужны условные операторы или блок команд, вызов find становится громоздким. В этом случае цикл for предпочтительнее.
------------------------------
В скрипте из листинга 3-27 конструкцию for можно заменить на while. Чтобы получить список файлов для обработки, вызовем утилиту find. При этом важно использовать её опцию -print0.

while IFS= read -r -d '' filename
do
  file "$filename"
done < <(find . -maxdepth 1 -print0)

В этом скрипте есть несколько важных решений. Рассмотрим их подробнее. Первый вопрос: зачем переменной IFS присваивать пустое значение? Без этого word splitting разделит вывод команды find пробелами, табуляцией и переводом строк. Тогда имена файлов с этими символами обработаются неправильно.
Второе важное решение — опция -d команды read. Она определяет символ для разделения текста на входе команды. В переменную filename запишется часть текста до очередного разделителя. В нашем примере разделитель для команды read пустой. Это означает NUL-символ. Его можно указать и явно. 

Например, так:

while IFS= read -r -d $'\0' filename

Благодаря опции -d, команда read правильно обработает вывод утилиты find. Утилита вызвана с опцией -print0. Это значит, что найденные файлы в выводе разделит NUL-символ. Обратите внимание, что указать NUL-символ в качестве разделителя через переменную IFS нельзя. Проблема в особенности интерпретации переменной IFS. Если её значение пустое, Bash
вообще не выполняет word splitting.

В скрипте из листинга 3-28 осталось ещё одно неочевидное решение. Вывод утилиты find передаётся в цикл while через подстановку процесса. Почему не подходит подстановка команды? Например, такая:

while IFS= read -r -d '' filename
do
  file "$filename"
done < $(find . -maxdepth 1 -print0)

Так перенаправить результат выполнения команды нельзя. Оператор < связывает поток ввода с указанным файловым дескриптором. Но при подстановке команды никакого дескриптора нет. Bash вызывает утилиту find и подставляет её вывод вместо $(...). При подстановке процессов вывод find запишется во временный файл. У него есть дескриптор. Поэтому перенаправление потоков сработает. У подстановки процессов есть одна проблема. Эта подстановка не входит в POSIX-стандарт. Если вам важно следовать стандарту, используйте конвейер. Листинг 3-29 демонстрирует
такое решение.

Листинг 3-29. Скрипт для вывода типов файлов

#!/bin/bash

find . -maxdepth 1 -print0 |
while IFS= read -r -d '' filename
do
  file "$filename"
done

Комбинация цикла while и утилиты find предпочтительнее for в одном случае: если вы обрабатываете файлы и условие их поиска сложное.
При комбинации while и find всегда используйте NUL-символ в качестве разделителя. Так вы избежите проблем обработки имён файлов с пробелами.
==============================
Вторая форма for

Во второй форме оператора for условием цикла выступает арифметическое выражение.

Листинг 3-30. Скрипт для расчёта факториала числа 5

#!/bin/bash

result=1

for i in {1..5}
do
  ((result *= $i))
done

echo "Факториал числа 5 равен $result"
------------------------------
Второй вариант — пользователь передаёт число для расчёта через входной параметр скрипта.

Для решения такой задачи попробуем следующий вариант условия цикла for:

for i in {1..$1}

Ожидается, что Bash выполнит подстановку фигурных скобок для целых чисел от одного до значения параметра $1. Это не сработает.

Подстановка фигурных скобок выполняется до подстановки пара-
метров. Поэтому в условии цикла вместо строки “1 2 3 4 5” получится строка “”. Bash не распознал подстановку фигурных скобок, потому что верхняя граница диапазона — не число. Дальше строка “” запишется в переменную i. Из-за этого оператор (( не сможет обработать её корректно.
Утилита seq решит нашу проблему. Она генерирует последовательность целых или дробных чисел.

Способы вызова утилиты seq:

Кол-во пар  Пример команды     Результат
1           seq 5               12345
2           seq -3 3            -2 -1 0 1 2
3           seq 1 2 5           135

Числа в выводе утилиты seq разделяются переводом строки \n. Опция -s позволяет указать другой разделитель. Перевод строки входит в список стандартных разделителей переменной IFS. Поэтому в конструкции for опция -s для seq не нужна.

Воспользуемся утилитой seq, чтобы написать параметризуемый скрипт для расчёта факториала:

result=1

for i in $(seq $1)
do
  ((result *= $i))
done

echo "Факториал числа $1 равен $result"

Это решение работает. Однако, его нельзя назвать эффективным. В условии цикла for вызывается внешняя утилита. Такой вызов сравним с запуском обычной программы. Например, калькулятора. Для создания нового процесса ядро ОС выполняет несколько сложных операций. По меркам процессора они занимают значительное время. Поэтому старайтесь обходиться встроенными средствами Bash везде, где это возможно.

Для решения задачи нам пригодится вторая форма оператора for. В общем виде она выглядит так:

for (( ВЫРАЖЕНИЕ_1; ВЫРАЖЕНИЕ_2; ВЫРАЖЕНИЕ_3 ))
do
  ДЕЙСТВИЕ
done

for (( ВЫРАЖЕНИЕ_1; ВЫРАЖЕНИЕ_2; ВЫРАЖЕНИЕ_3 )); do ДЕЙСТВИЕ; done

Цикл for с арифметическим условием работает так:
1. ВЫРАЖЕНИЕ_1 выполняется однократно перед первой итерацией цикла.
2. Цикл выполняется до тех пор, пока ВЫРАЖЕНИЕ_2 остаётся истинным. Как только оно вернуло ложь в качестве результата, цикл завершается.
3. В конце каждой итерации выполняется ВЫРАЖЕНИЕ_3.

Заменим вызов утилиты seq на арифметическое выражение.

result=1

for (( i = 1; i <= $1; ++i ))
do
  ((result *= i))
done

echo "Факториал числа $1 равен $result"

Скрипт стал работать быстрее. Теперь он использует только встроенные операторы Bash. Для их исполнения не нужно создавать новые процессы.

Рассмотрим алгоритм конструкции for в скрипте:

1. Перед первой итерацией цикла объявляется переменная i. Это счётчик цикла. Ему присваивается единица.
2. Счётчик цикла сравнивается с входным параметром: “i <= $1”. Если условие выполняется, возвращается нулевой код возврата.
3. Если условие вернуло ноль, выполняется первая итерация цикла. В противном случае цикл завершается.
4. В теле цикла вычисляется арифметическое выражение “result *= i”. В результате значение переменной result будет умножено на i.
5. После выполнения первой итерации, вычисляется третье выражение ++i в условии цикла. В результате значение переменной i станет равно двум.
6. Переход ко второму шагу алгоритма с проверкой условия “i <= $1”. Если условие попрежнему истинно, выполняется следующая итерация цикла.

В общем случае для переменных в операторе (( и команде let знака доллара $ не нужен. Однако, в нашем условии цикла он необходим. Без него Bash не поймёт, что имеется ввиду позиционный параметр $1, а не целое число единица.

В цикле мы используем префиксную форму инкремента. Она выполняется быстрее, чем постфиксная.

Используйте вторую форму оператора for, если счётчик цикла рассчитывается по формуле. Других эффективных решений в этом случае нет.
------------------------------
Нули в начале числа

for i in {01..10}; do echo "$i"; done

В bash версии 4.0 и выше, если любой из первых двух членов в выражении вида {начало..конец..шаг} начинается с нуля, то переменная цикла будет принимать значения одинаковой длины и дополняться нулями слева. То есть при использовании выражения {098..100} переменная цикла будет последовательно принимать значения 098, 099, 100, а в случае {98..0100} каждое значение будет иметь длину в 4 символа: 0098, 0099, 0100.
==============================
Управление циклом
==============================
break

Встроенная команда break немедленно прекращает выполнение цикла. Она полезна для обработки ошибок или выхода из бесконечного цикла.

Если не имеет смысла выполнять скрипт после завершения цикла, команда break не подойдёт. Вместо неё используйте команду exit. Например, если во входных данных скрипта обнаружилась ошибка. Также exit подойдёт, если результат работы цикла обрабатывается в его теле.
------------------------------
continue

Встроенная команда continue прекращает исполнение текущей итерации цикла. При этом цикл не завершится. Он продолжит выполняться со следующей итерации.

Используйте команду continue, чтобы обработать ошибки. Также она пригодится для условий, когда выполнять тело цикла до конца не имеет смысла. Так вы избежите вложенных конструкций if.
==============================


