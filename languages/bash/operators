###
==============================
Операторы в bash
==============================
Арифметические операторы
------------------------------

В Bash арифметика выполняется с помощью:

1) Конструкции $(( ... )).
2) Команды let.
3) Утилиты expr (устаревший метод).

Примеры:

+   Сложение    echo $((5 + 3)) → 8
-   Вычитание   let result=10-4 → 6
*   Умножение   expr 3 \* 2 → 6
/   Деление     echo $((10 / 3)) → 3
%	Дел(ост)    echo $((10 % 3)) → 1
**	В степень   echo $((2 ** 3)) → 8
++	Инкремент	let a=5; echo $((a++)) → 6
--	Декремент	let a=5; echo $((--a)) → 4

------------------------------
Операторы сравнения
------------------------------

Используются для проверки условий в конструкциях if, while и т.д.

Для чисел (внутри [ ] или [[ ]]):

-eq	    Равно               [ "$a" -eq 5 ]
-ne	    Не равно	        [[ "$a" -ne 10 ]]
-gt	    Больше              [ "$a" -gt 3 ]
-lt	    Меньше	            [[ "$a" -lt 7 ]]
-ge	    Больше или равно	[ "$a" -ge 5 ]
-le	    Меньше или равно	[[ "$a" -le 10 ]]

Для строк (внутри [[ ]]):

==  Равно           [[ "$str" == "test" ]]
!=	Не равно	    [[ "$str" != "no" ]]
=~	Регулярка	    [[ "$str" =~ ^a.*z$ ]]
-z	Пустая стр  	[ -z "$str" ]
-n	Непустая стр	[ -n "$str" ]

Для файлов (внутри [[ ]]:

-L "путь"
Проверяет, существует ли символьная ссылка (symbolic link) по указанному пути.

-f "путь"
Проверяет, существует ли обычный (не каталог, не устройство, не ссылкa) файл (regular file) по указанному пути.

-d	Является каталогом
-e	Файл/объект существует (любого типа)
-s	Файл существует И не пустой
-r	Файл доступен для чтения
-w	Файл доступен для записи
-x	Файл доступен для выполнения
------------------------------
Логические операторы
------------------------------

Используются для комбинирования условий.

&&  Логическое И (AND) - выполняет следующую команду только в случае успешного завершения предыдущей команды.
||  Логическое ИЛИ (OR) - выполняет следующую команду только в случае неуспешного завершения предыдущей команды. 
!	Логическое НЕ (NOT)     [ ! -f "file.txt" ]

------------------------------
Операторы присваивания
------------------------------

Присваивание значения переменной:
var="значение"

Арифметическое присваивание (внутри (( ))):
(( a += 5 ))  # Эквивалентно a = a + 5

------------------------------
Операторы перенаправления ввода-вывода
------------------------------

>	Перезапись файла	        echo "text" > file.txt
>>	Добавл в конец файла    	date >> log.txt
<   Чтение из файла	            wc -l < input.txt
2>	Перенаправление stderr	    ls nofile 2> error.log
&>	Перен stdout и stderr	    command &> output.log
|   Конвейер                    ls -l | grep ".txt"

------------------------------
Операторы управления процессами
------------------------------

&   Запуск в фоновом режиме             sleep 10 &
;	Выполнение команд последовательно   
&&	Выполнить следующую команду, если предыдущая успешна
||  Выполнить следующую команду, если предыдущая провалилась	
()	Группировка команд	

------------------------------
Операторы подстановки
------------------------------

$() Подстановка вывода команды	            echo "Дата: $(date)"
``  Альтернативный синтаксис подстановки	echo "Дата: `date`"
{}  Генерация списков	                    echo file{1..3}.txt
==============================


==============================
Подробное сравнение [ ] и [[ ]]
==============================
Происхождение
------------------------------

[ ] (синоним команды test):
Это встроенная команда Bash, которая также доступна как отдельная утилита в Unix-системах.
[ "$a" -eq 5 ]  # Эквивалентно команде test "$a" -eq 5

[[ ]]: более новое дополнение Bash, поэтому не всегда доступно в старых системах.

------------------------------
Обработка строк и переменных
------------------------------

[ ]:
- Переменные обязательно заключать в кавычки, чтобы избежать ошибок при наличии пробелов или специальных символов.
- 

[[ ]]:
- Кавычки не обязательны (но их можно использовать для явного указания строки).

------------------------------
Логические операторы
------------------------------

[ ]:
Используются флаги -a (AND), -o (OR), а ! для отрицания.
[ "$x" -gt 5 -a "$y" -lt 10 ]

[[ ]]:
Используются символы && (AND), || (OR), ! (NOT).
[[ "$x" > 5 && "$y" < 10 ]]

------------------------------
Сравнение строк и чисел
------------------------------

[ ]:
Для чисел используются операторы -eq, -ne, -gt, -lt и т.д.
Для строк — = и !=.

[[ ]]:
Можно использовать как числовые операторы (-eq, -gt), так и строковые (==, !=, <, >).
Лексикографическое сравнение строк с < и > (в [ ] эти символы нужно экранировать: \<, \>).

------------------------------
Регулярные выражения
------------------------------

Только в [[ ]]:
Можно использовать оператор =~ для проверки соответствия регулярному выражению.
Результат сохраняется в массиве BASH_REMATCH (индекс 0 — вся подстрока, 1, 2, ... — группы).

------------------------------
Группировка условий
------------------------------

[ ]:
Группировка с помощью \( ... \) и экранирования.
[ \( "$a" -eq 5 -o "$b" -eq 10 \) -a "$c" -gt 3 ]

[[ ]]:
Группировка с помощью круглых скобок без экранирования.
[[ ($x > 5 || $y < 10) && ! -z "$str" ]]

------------------------------
Работа с шаблонами (подстановками)
------------------------------

[ ]:
Для этого требуется использовать внешние команды (например, case или grep).

[[ ]]:
Можно использовать подстановки (wildcards) в стиле glob (например, *, ?).
[[ "file.txt" == *.txt ]]

------------------------------
Обработка ошибок
------------------------------

[ ]:
Если переменная не определена, могут возникать ошибки.
[ "$undefined_var" = 5 ]  # Ошибка, если переменная пуста (лучше использовать [ "${undefined_var}" = 5 ]).

[[ ]]:
Более устойчив к пустым переменным:
[[ $undefined_var == 5 ]]  # Не вызывает ошибки, даже если переменная не определена.

------------------------------
Переносимость
------------------------------

[ ]:
Работает во всех POSIX-совместимых оболочках (sh, dash, ksh).

[[ ]]:
Специфичен для Bash и некоторых продвинутых оболочек (например, zsh). Не совместим с POSIX.
==============================
Условные операторы
==============================
Оператор if
==============================
Конструкция if введена в язык Bash как раз для удобства работы с блоками команд. В общем
случае она выглядит так:

if УСЛОВИЕ_1
then
ДЕЙСТВИЕ_1
elif УСЛОВИЕ_2
then
ДЕЙСТВИЕ_2
else
ДЕЙСТВИЕ_3
fi

Kонструкцию можно записать и в одну строку:
if УСЛОВИЕ; then ДЕЙСТВИЕ; fi
------------------------------
«Ранний возврат» — это концепт написания функций таким образом, что ожидаемый положительный результат возвращается в конце, когда остальной код в случае расхождения с целью функции должен завершить ее выполнение настолько раньше, насколько возможно.

Например:

if ДЕЙСТВИЕ_1
then
    if ДЕЙСТВИЕ_2
    then
        if ДЕЙСТВИЕ_3
        then
            if ДЕЙСТВИЕ_4
            then
            ДЕЙСТВИЕ_5
            fi
        fi
    fi
fi

Применим технику раннего возврата:

if ! ДЕЙСТВИЕ_1
then
# обработка ошибки
fi

if ! ДЕЙСТВИЕ_2
then
# обработка ошибки
fi

if ! ДЕЙСТВИЕ_3
then
# обработка ошибки
fi

if ! ДЕЙСТВИЕ_4
then
# обработка ошибки
fi

ДЕЙСТВИЕ_5
==============================
Оператор case
==============================
В общем случае конструкция case сравнивает переданную в неё строку со списком шаблонов.
В зависимости от совпадения с шаблоном выполняется один из блоков case.
Каждый блок case состоит из следующих элементов:
1. Шаблон или список шаблонов, разделённых символом |.
2. Правая круглая скобка ).
3. Набор команд, которые выполняются при совпадении шаблона и переданной в case строки.
4. Два знака точка с запятой ;;. Они означают окончание набора команд.

case СТРОКА in
  ШАБЛОН_1)
    ДЕЙСТВИЕ_1
    ;;
  ШАБЛОН_2)
    ДЕЙСТВИЕ_2
    ;;
  ШАБЛОН_3)
    ДЕЙСТВИЕ_3
    ;;
esac

Блоки case можно отделять друг от друга двумя знаками точка с запятой ;; или точкой с запятой и амперсандом ;&.
Синтаксис с амперсандом допустим в Bash, но не является частью POSIX-стандарта. Он означает выполнение следующего блока case без проверки его шаблона.
Это может быть полезно, если требуется начать выполнение алгоритма с определённого шага в зависимости от какого-то условия. Также синтаксис с амперсандом позволяет избежать дублирования кода.
------------------------------
Альтернатива оператору case
------------------------------
Конструкция case и ассоциативный массив решают сходные задачи. Массив даёт соотношение между данными (ключ-значение). Конструкция case — между данными и командами (значение-действие).

utility="$1"

case "$utility" in
  "-b"|"--bsdtar")
    bsdtar "${@:2}"
    ;;
  "-t"|"--tar")
    tar "${@:2}"
    ;;
  *)
    echo "Указана недопустимая опция"
    exit 1
    ;;
esac

Первый параметр скрипт обрабатывает самостоятельно. Все последующие параметры передаются в утилиту архивации без изменений. Для такой передачи мы используем параметр $@.
Это не массив. Но он поддерживает синтаксис для подстановки следующих подряд элементов массива. В скрипте мы подставляем в вызов утилиты архивации все элементы $@ начиная со второго.

option="$1"

declare -A utils=(
  ["-b"]="bsdtar"
  ["--bsdtar"]="bsdtar"
  ["-t"]="tar"
  ["--tar"]="tar")

if [[ -z "$option" || ! -v utils["$option"] ]]
  then
    echo "Указана недопустимая опция"
    exit 1
fi

${utils["$option"]} "${@:2}"

Массив в некоторых случаях даёт более компактный и
удобный для чтения код. Всегда рассматривайте возможность заменить конструкцию case
на массив в своих программах.
==============================



