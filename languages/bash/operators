###
==============================
Операторы в bash
==============================
Арифметические операторы
------------------------------

В Bash арифметика выполняется с помощью:

1) Конструкции $(( ... )).
2) Команды let.
3) Утилиты expr (устаревший метод).

Примеры:

+   Сложение    echo $((5 + 3)) → 8
-   Вычитание   let result=10-4 → 6
*   Умножение   expr 3 \* 2 → 6
/   Деление     echo $((10 / 3)) → 3
%	Дел(ост)    echo $((10 % 3)) → 1
**	В степень   echo $((2 ** 3)) → 8
++	Инкремент	let a=5; echo $((a++)) → 6
--	Декремент	let a=5; echo $((--a)) → 4

------------------------------
Операторы сравнения
------------------------------

Используются для проверки условий в конструкциях if, while и т.д.

Для чисел (внутри [ ] или [[ ]]):

-eq	    Равно               [ "$a" -eq 5 ]
-ne	    Не равно	        [[ "$a" -ne 10 ]]
-gt	    Больше              [ "$a" -gt 3 ]
-lt	    Меньше	            [[ "$a" -lt 7 ]]
-ge	    Больше или равно	[ "$a" -ge 5 ]
-le	    Меньше или равно	[[ "$a" -le 10 ]]

Для строк (внутри [[ ]]):

==  Равно           [[ "$str" == "test" ]]
!=	Не равно	    [[ "$str" != "no" ]]
=~	Регулярка	    [[ "$str" =~ ^a.*z$ ]]
-z	Пустая стр  	[ -z "$str" ]
-n	Непустая стр	[ -n "$str" ]

------------------------------
Логические операторы
------------------------------

Используются для комбинирования условий.

&&  Логическое И (AND) - выполняет следующую команду только в случае успешного завершения предыдущей команды.
||  Логическое ИЛИ (OR) - выполняет следующую команду только в случае неуспешного завершения предыдущей команды. 
!	Логическое НЕ (NOT)     [ ! -f "file.txt" ]

------------------------------
Операторы присваивания
------------------------------

Присваивание значения переменной:
var="значение"

Арифметическое присваивание (внутри (( ))):
(( a += 5 ))  # Эквивалентно a = a + 5

------------------------------
Операторы перенаправления ввода-вывода
------------------------------

>	Перезапись файла	        echo "text" > file.txt
>>	Добавл в конец файла    	date >> log.txt
<   Чтение из файла	            wc -l < input.txt
2>	Перенаправление stderr	    ls nofile 2> error.log
&>	Перен stdout и stderr	    command &> output.log
|   Конвейер                    ls -l | grep ".txt"

------------------------------
Операторы управления процессами
------------------------------

&   Запуск в фоновом режиме             sleep 10 &
;	Выполнение команд последовательно   
&&	Выполнить следующую команду, если предыдущая успешна
||  Выполнить следующую команду, если предыдущая провалилась	
()	Группировка команд	

------------------------------
Операторы подстановки
------------------------------

$() Подстановка вывода команды	            echo "Дата: $(date)"
``  Альтернативный синтаксис подстановки	echo "Дата: `date`"
{}  Генерация списков	                    echo file{1..3}.txt
==============================


==============================
Подробное сравнение [ ] и [[ ]]
==============================
Происхождение
------------------------------

[ ] (синоним команды test):
Это встроенная команда Bash, которая также доступна как отдельная утилита в Unix-системах.
[ "$a" -eq 5 ]  # Эквивалентно команде test "$a" -eq 5

[[ ]]: более новое дополнение Bash, поэтому не всегда доступно в старых системах.

------------------------------
Обработка строк и переменных
------------------------------

[ ]:
- Переменные обязательно заключать в кавычки, чтобы избежать ошибок при наличии пробелов или специальных символов.
- 

[[ ]]:
- Кавычки не обязательны (но их можно использовать для явного указания строки).

------------------------------
Логические операторы
------------------------------

[ ]:
Используются флаги -a (AND), -o (OR), а ! для отрицания.
[ "$x" -gt 5 -a "$y" -lt 10 ]

[[ ]]:
Используются символы && (AND), || (OR), ! (NOT).
[[ "$x" > 5 && "$y" < 10 ]]

------------------------------
Сравнение строк и чисел
------------------------------

[ ]:
Для чисел используются операторы -eq, -ne, -gt, -lt и т.д.
Для строк — = и !=.

[[ ]]:
Можно использовать как числовые операторы (-eq, -gt), так и строковые (==, !=, <, >).
Лексикографическое сравнение строк с < и > (в [ ] эти символы нужно экранировать: \<, \>).

------------------------------
Регулярные выражения
------------------------------

Только в [[ ]]:
Можно использовать оператор =~ для проверки соответствия регулярному выражению.
Результат сохраняется в массиве BASH_REMATCH (индекс 0 — вся подстрока, 1, 2, ... — группы).

------------------------------
Группировка условий
------------------------------

[ ]:
Группировка с помощью \( ... \) и экранирования.
[ \( "$a" -eq 5 -o "$b" -eq 10 \) -a "$c" -gt 3 ]

[[ ]]:
Группировка с помощью круглых скобок без экранирования.
[[ ($x > 5 || $y < 10) && ! -z "$str" ]]

------------------------------
Работа с шаблонами (подстановками)
------------------------------

[ ]:
Для этого требуется использовать внешние команды (например, case или grep).

[[ ]]:
Можно использовать подстановки (wildcards) в стиле glob (например, *, ?).
[[ "file.txt" == *.txt ]]

------------------------------
Обработка ошибок
------------------------------

[ ]:
Если переменная не определена, могут возникать ошибки.
[ "$undefined_var" = 5 ]  # Ошибка, если переменная пуста (лучше использовать [ "${undefined_var}" = 5 ]).

[[ ]]:
Более устойчив к пустым переменным:
[[ $undefined_var == 5 ]]  # Не вызывает ошибки, даже если переменная не определена.

------------------------------
Переносимость
------------------------------

[ ]:
Работает во всех POSIX-совместимых оболочках (sh, dash, ksh).

[[ ]]:
Специфичен для Bash и некоторых продвинутых оболочек (например, zsh). Не совместим с POSIX.
==============================
