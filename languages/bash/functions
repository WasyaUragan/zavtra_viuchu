==============================
Функции
==============================
Bash относится к процедурным языкам программирования. Процедурные языки позволяют разделить программу на логические части — подпрограммы. Подпрограмма — это самостоятельный блок кода, который решает конкретную задачу. Подпрограммы вызываются из основной программы.

В современных языках подпрограммы называются функциями.
------------------------------
Парадигмы программирования

1. Императивное программирование. Разработчик явно указывает машине, как ей изменять своё состояние. Другими словами он задаёт полный алгоритм вычисления результата.

2. Декларативное программирование. Разработчик указывает свойства желаемого результата, но не алгоритм его вычисления.
------------------------------
Bash следует первой парадигме. Это императивный язык.

Так у императивной парадигмы есть две основных методологии:

1. Процедурное программирование.
2. Объектно-ориентированное программирование.

Bash следует первой методологии.
------------------------------
Процедурный язык предоставляет средства для объединения наборов команд в независимые блоки кода. Эти блоки кода называются процедурами или функциями. Функцию можно вызвать из любого места программы. На вход она принимает параметры. Этот механизм похож на передачу параметров командной строки в скрипт. Поэтому функцию иногда называют программой в программе или подпрограммой.
==============================
Функции в командном интерпретаторе
==============================

ИМЯ_ФУНКЦИИ()
{
ДЕЙСТВИЕ
}

ИМЯ_ФУНКЦИИ() { ДЕЙСТВИЕ ; }
------------------------------
На имена функций в Bash накладываются те же ограничения, что и на имена переменных. В них допустимы только символы латинского алфавита, числа и знак подчёркивания _. Имя не должно начинаться с числа.
------------------------------
Объявление функции можно добавить в файл ∼/.bashrc. Тогда функция будет доступна при каждом запуске командной оболочки.
------------------------------
Предположим, что переменная и функция объявлены с одинаковыми именами. Чтобы удалить именно функцию, используйте опцию -f команды unset

unset -f mem
==============================
Отличие функций от псевдонимов

mem()
{
cat /proc/meminfo
}

Мы объявили функцию mem для вывода статистики использования оперативной памяти. То же поведение даст следующий псевдоним:

alias mem="cat /proc/meminfo"

Функции и псевдонимы похожи в одном — это встроенные механизмы Bash. С точки зрения пользователя они сокращают ввод длинных команд. Но принцип работы этих механизмов принципиально различается.

Псевдоним заменяет один текст на другой во введённой пользователем команде. Другими словами Bash находит в команде текст, который совпадает с именем alias. Затем заменяет этот текст на значение псевдонима и исполняет получившуюся команду.

Чтобы подставить значение alias до исполнения команды, введите её и нажмите Ctrl+Alt+E.
------------------------------
В отличие от псевдонима тело функции не подставляется в команду. Когда Bash встречает имя функции в команде, он исполняет её тело.
==============================
В общем виде вызов функции и передача в неё параметров выглядит так:

ИМЯ_ФУНКЦИИ ПАРАМЕТР1 ПАРАМЕТР2 ПАРАМЕТР3
------------------------------
Чтобы прочитать параметры в теле функции, используйте переменные $1, $2, $3 и т.д. Прочитать сразу все параметры можно через переменную $@.

cat() { cat -n $@; }

Такая функция не заработает. Дело в том, что при её выполнении произойдёт рекурсия. Рекурсией называется вызов функции из неё же самой.

Перед выполнением команды “cat -n $@” Bash проверит список объявленных функций. В списке будет функция с именем cat. Её тело выполняется в данный момент, но это не важно. Поэтому вместо вызова утилиты Bash вызовет функцию cat. Этот вызов повторится снова и снова. Возникнет бесконечная рекурсия, которая похожа на бесконечный цикл.

Рекурсия — вовсе не ошибка в поведении интерпретатора. Это мощный механизм, который значительно упрощает сложные алгоритмы (например, обход графа или дерева).

Ошибка в нашем объявлении функции cat. Рекурсивный вызов произошел случайно и привел к зацикливанию. Решить эту проблему можно двумя способами:

1. Использовать встроенную команду command.

В качестве параметров command получает команду. Если в команде встречаются имена псевдонимов и функций, Bash не станет их обрабатывать. Тело псевдонима не подставится. Функция не вызовется.

cat() { command cat -n "$@"; }

2. Переименовать функцию так, чтобы её имя отличалось от имени утилиты.

cat_func() { cat -n "$@"; }
------------------------------
Если нужно просто сократить длинную команду, используйте alias.

Функция нужна только в следующих случаях:
1. Для выполнения действия нужны условные операторы, циклы или блок команд.
2. Параметры команды находятся не в конце.

Рассмотрим пример второго случая — команду, которую нельзя заменить псевдонимом. Сократим вызов утилиты find для поиска файлов в указанном каталоге. Поиск в домашнем каталоге выглядит так:

find ~ -type f

С помощью псевдонима для этой команды параметризовать путь не получится. Следующий вариант не заработает:

alias="find -type f"

Проблема в том, что путь должен идти до опции -type.
Заменим псевдоним на функцию. В её теле можно выбрать позицию для подстановки параметра в вызов find. Например, так:

find_func() { find $1 -type f; }
==============================
Функции в скриптах
==============================

print_error()
{
>&2 echo "Произошла ошибка: $@"
}

Текст, объясняющий причину ошибки, передаётся в функцию через параметр.

print_error "файл readme.txt не найден"

Предположим, что требования к программе изменились. Теперь сообщения об ошибках нужно выводить в лог-файл.

Команда echo изменится на следующую:

print_error()
{
echo "Произошла ошибка: $@" >> debug.log
}

Менять что-либо в местах вызова функции не нужно.
==============================
Возврат результата функции
==============================
Чтобы вернуть результат функции, процедурные языки имеют встроенную команду. Обычно она называется return. В Bash эта команда тоже есть. Но её поведение отличается. Команда return в Bash не возвращает значение. Она передаёт код возврата, то есть целое число от 0 до 255.

Полный алгоритм вызова и выполнения функции выглядит так:

1. При выполнении команды встречается имя функции.
2. Интерпретатор переходит в тело функции и исполняет его с первой команды.
3. Если в теле функции встречается команда return, выполнение функции прекращается. Bash переходит в место её вызова. В специальный параметр $? записывается код возврата функции. Это параметр команды return.
4. Если в теле функции нет return, Bash выполняет его до последней команды. После этого интерпретатор переходит в место вызова функции.

В других процедурных языках команда return возвращает переменную любого типа: число, строку или массив. Такое же поведение можно получить и в Bash.
------------------------------
Для этого есть три способа:
------------------------------
1. Подстановка команд.

code_to_error()
{
    case $1 in
      1)
        echo "Не найден файл"
        ;;
      2)
        echo "Нет прав для чтения файла"
        ;;
    esac
}

print_error()
{
    echo "$(code_to_error $1) $2" >> debug.log
}

Вызов функции code_to_error помещается в подстановку команды. Благодаря этому, Bash подставит в место вызова функции всё, что она выведет на консоль.
------------------------------
2. Глобальная переменная.

Все глобальные переменные, через которые функции возвращают значения, имеют префикс знак подчёркивания _.

code_to_error()
{
    case $1 in
      1)
        _error_text="Не найден файл"
        ;;
      2)
        _error_text="Нет прав для чтения файла"
        ;;
    esac
}

print_error()
{
    code_to_error $1
    echo "$_error_text $2" >> debug.log
}

Результат функции code_to_error записывается в переменную error_text. Затем значения параметра $2 и error_text подставляются в команду echo в функции print_error. Так получается сообщение для вывода в лог-файл.


------------------------------
3. Вызывающая сторона указывает глобальную переменную.

Этот способ возврата значения из функции решает проблему конфликта имён.Вызывающая сторона задаёт имя глобальной переменной. Функция записывает свой результат в переменную с этим именем.

Имя передаётся через параметр функции, как и любое другое значение. Дальше, функция использует команду eval. Эта команда конвертирует текст в Bash-команду. Имя переменной хранится в виде текста. Поэтому без eval обратиться к переменной не получится.


code_to_error()
{
    local _result_variable=$2

    case $1 in
      1)
        eval $_result_variable="'Не найден файл'"
        ;;
      2)
        eval $_result_variable="'Нет прав для чтения файла'"
        ;;
    esac
}

print_error()
{
code_to_error $1 "error_text"
    echo "$error_text $2" >> debug.log
}
==============================
Область видимости переменных
==============================
Чтобы решить конфликт имён в Bash, ограничивайте область видимости переменных.

Если объявить переменную с ключевым словом local, её область видимости ограничится телом функции. Другими словами, переменная будет доступна только в теле функции.

В Bash область видимости локальной переменной ограничена временем исполнения функции, в которой она объявлена. Такая область видимости называется динамической. В современных языках чаще встречается лексическая область видимости. При этом подходе переменная доступна только в теле функции, но не за его пределами (например, в вызываемых функциях).

Локальные переменные не попадают в глобальную область видимости. Это гарантирует, что никакая функция не перезапишет их случайно.

Глобальная переменная становится недоступна в теле функции только после объявления локальной переменной с тем же именем.

