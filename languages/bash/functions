==============================
Функции
==============================
Bash относится к процедурным языкам программирования. Процедурные языки позволяют разделить программу на логические части — подпрограммы. Подпрограмма — это самостоятельный блок кода, который решает конкретную задачу. Подпрограммы вызываются из основной программы.

В современных языках подпрограммы называются функциями.
------------------------------
Парадигмы программирования

1. Императивное программирование. Разработчик явно указывает машине, как ей изменять своё состояние. Другими словами он задаёт полный алгоритм вычисления результата.

2. Декларативное программирование. Разработчик указывает свойства желаемого результата, но не алгоритм его вычисления.
------------------------------
Bash следует первой парадигме. Это императивный язык.

Так у императивной парадигмы есть две основных методологии:

1. Процедурное программирование.
2. Объектно-ориентированное программирование.

Bash следует первой методологии.
------------------------------
Процедурный язык предоставляет средства для объединения наборов команд в независимые блоки кода. Эти блоки кода называются процедурами или функциями. Функцию можно вызвать из любого места программы. На вход она принимает параметры. Этот механизм похож на передачу параметров командной строки в скрипт. Поэтому функцию иногда называют программой в программе или подпрограммой.
==============================
Функции в командном интерпретаторе
==============================

ИМЯ_ФУНКЦИИ()
{
ДЕЙСТВИЕ
}

ИМЯ_ФУНКЦИИ() { ДЕЙСТВИЕ ; }
------------------------------
На имена функций в Bash накладываются те же ограничения, что и на имена переменных. В них допустимы только символы латинского алфавита, числа и знак подчёркивания _. Имя не должно начинаться с числа.
------------------------------
Объявление функции можно добавить в файл ∼/.bashrc. Тогда функция будет доступна при каждом запуске командной оболочки.
------------------------------
Предположим, что переменная и функция объявлены с одинаковыми именами. Чтобы удалить именно функцию, используйте опцию -f команды unset

unset -f mem
==============================
Отличие функций от псевдонимов

mem()
{
cat /proc/meminfo
}

Мы объявили функцию mem для вывода статистики использования оперативной памяти. То же поведение даст следующий псевдоним:

alias mem="cat /proc/meminfo"

Функции и псевдонимы похожи в одном — это встроенные механизмы Bash. С точки зрения пользователя они сокращают ввод длинных команд. Но принцип работы этих механизмов принципиально различается.

Псевдоним заменяет один текст на другой во введённой пользователем команде. Другими словами Bash находит в команде текст, который совпадает с именем alias. Затем заменяет этот текст на значение псевдонима и исполняет получившуюся команду.

Чтобы подставить значение alias до исполнения команды, введите её и нажмите Ctrl+Alt+E.
------------------------------
В отличие от псевдонима тело функции не подставляется в команду. Когда Bash встречает имя функции в команде, он исполняет её тело.
==============================
В общем виде вызов функции и передача в неё параметров выглядит так:

ИМЯ_ФУНКЦИИ ПАРАМЕТР1 ПАРАМЕТР2 ПАРАМЕТР3
------------------------------
Чтобы прочитать параметры в теле функции, используйте переменные $1, $2, $3 и т.д. Прочитать сразу все параметры можно через переменную $@.

cat() { cat -n $@; }

Такая функция не заработает. Дело в том, что при её выполнении произойдёт рекурсия. Рекурсией называется вызов функции из неё же самой.

Перед выполнением команды “cat -n $@” Bash проверит список объявленных функций. В списке будет функция с именем cat. Её тело выполняется в данный момент, но это не важно. Поэтому вместо вызова утилиты Bash вызовет функцию cat. Этот вызов повторится снова и снова. Возникнет бесконечная рекурсия, которая похожа на бесконечный цикл.

Рекурсия — вовсе не ошибка в поведении интерпретатора. Это мощный механизм, который значительно упрощает сложные алгоритмы (например, обход графа или дерева).

Ошибка в нашем объявлении функции cat. Рекурсивный вызов произошел случайно и привел к зацикливанию. Решить эту проблему можно двумя способами:

1. Использовать встроенную команду command.

В качестве параметров command получает команду. Если в команде встречаются имена псевдонимов и функций, Bash не станет их обрабатывать. Тело псевдонима не подставится. Функция не вызовется.

cat() { command cat -n "$@"; }

2. Переименовать функцию так, чтобы её имя отличалось от имени утилиты.

cat_func() { cat -n "$@"; }
------------------------------
Если нужно просто сократить длинную команду, используйте alias.

Функция нужна только в следующих случаях:
1. Для выполнения действия нужны условные операторы, циклы или блок команд.
2. Параметры команды находятся не в конце.

Рассмотрим пример второго случая — команду, которую нельзя заменить псевдонимом. Сократим вызов утилиты find для поиска файлов в указанном каталоге. Поиск в домашнем каталоге выглядит так:

find ~ -type f

С помощью псевдонима для этой команды параметризовать путь не получится. Следующий вариант не заработает:

alias="find -type f"

Проблема в том, что путь должен идти до опции -type.
Заменим псевдоним на функцию. В её теле можно выбрать позицию для подстановки параметра в вызов find. Например, так:

find_func() { find $1 -type f; }
==============================
Функции в скриптах
==============================

print_error()
{
>&2 echo "Произошла ошибка: $@"
}

Текст, объясняющий причину ошибки, передаётся в функцию через параметр.

print_error "файл readme.txt не найден"

Предположим, что требования к программе изменились. Теперь сообщения об ошибках нужно выводить в лог-файл.

Команда echo изменится на следующую:

print_error()
{
echo "Произошла ошибка: $@" >> debug.log
}

Менять что-либо в местах вызова функции не нужно.
------------------------------




