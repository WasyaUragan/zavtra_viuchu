###
==============================
Арифметические выражения
==============================
В Bash для арифметики с плавающей точкой используйте калькулятор bc или dc.
------------------------------
Представление целых чисел

Целые числа могут быть положительными и отрицательными. Соответствующий им тип данных называется целое (integer).
Если переменная целого типа принимает только положительные значения, она называется беззнаковой (unsigned).
Если допустимы как положительные, так и отрицательные значения — это переменная со знаком (signed).

Наиболее распространены три способа представления целых в памяти компьютера:

1) Прямой код (signed magnitude representation или SMR).
2) Обратный код (ones’ complement).
3) Дополнительный код (two’s complement).
------------------------------
Прямой код
1. Для записи только положительных целых (беззнаковых).
2. Для записи как положительных, так и отрицательных целых (со знаком).

Предположим, что на число выделен один байт памяти. Тогда в прямом коде можно сохранить целые беззнаковые числа от 0 до 255.
Прямой код можно использовать вторым способом. Он позволяет хранить целые числа со знаком. Для этого старший бит числа резервируется для знака. Поэтому на значение числа остаётся меньше битов. Например, отведём для хранения числа один байт памяти. Один бит уйдёт на знак. Останется только семь битов на значение числа.

Из-за знака теперь нельзя сохранить числа больше 127 в одном байте. По этой же причине минимальное отрицательное число равно -127
------------------------------
Обратный код

У любого современного
процессора есть стандартный модуль под названием сумматор. Он побитово складывает два числа. Если применить его для нашей задачи, получим следующее:

10 + (-5) = 0000 1010 + 1000 0101 = 1000 1111 = -15

Результат неверный. Это означает, что сумматор не подходит для сложения целых в прямом коде. Проблема в том, что при сложении не учитывается старший бит числа.

Принцип работы обратного кода очень похож на прямой код. Старший бит отводится под знак. Остальные биты хранят значение числа. Отличие в том, что для отрицательных чисел все биты значения инвертируются. То есть нули становятся единицами, а единицы — нулями. Биты значения положительных чисел не инвертируются.

Вместимость памяти при использовании прямого и обратного кодов одинакова. В одном байте по-прежнему можно сохранить числа от -127 до 127.

Представим 10 и -5 в обратном коде. Затем сложим их с помощью сумматора.

10 + (-5) = 0000 1010 + 1111 1010 = 1 0000 0100

Обратите внимание, что в результате сложения произошло переполнение. Старшая единица не поместилась в один байт, отведённый под число. В этом случае она отбрасывается.

Отброшенная единица влияет на конечный результат. Нужен второй этап вычисления, чтобы её учесть.

На этом этапе просто добавим единицу к результату:

0000 0100 + 0000 0001 = 0000 0101 = 5

Если в результате сложения получилось отрицательное число, второй этап вычисления не нужен.

У прямого кода есть вторая проблема: представление нуля двумя способами. Её обратный код решить не смог.
------------------------------
Дополнительный код

Дополнительный код решает обе проблемы прямого кода. Во-первых, он позволяет стандартному сумматору складывать отрицательные числа. В обратном коде это действие выполняется в два этапа. В дополнительном коде достаточно одного. Во-вторых, ноль представляется одним единственным способом. Положительные числа в дополнительном коде выглядят так же, как и в прямом. Старший знаковый бит равен нулю. Остальные биты хранят значение числа. У отрицательных чисел старший бит равен единице. Биты значения инвертируются, как в обратном коде. Затем к результату прибавляется единица.

Вместимость памяти при использовании дополнительного кода не меняется. По-прежнему в одном байте можно сохранить числа от -127 до 127.

Дополнительный код позволил стандартному сумматору складывать отрицательные числа. Результат сложения вычисляется за один этап. Поэтому в отличие от обратного кода нет потери производительности. Дополнительный код решил проблему представления нуля. Все биты этого числа — нули. Других вариантов нет. Поэтому сравнивать числа стало проще. Во всех современных компьютерах целые представляются в дополнительном коде.

Сложение чисел в доп коде:
1 + 0 = 1
1 + 1 = 0
0 + 0 = 1
==============================
Оператор ((
==============================
Bash выполняет целочисленную арифметику в математическом контексте (math context).

declare -i var=12+7

В результате переменная будет равна числу 19, а не строке “12+7”. Если объявить переменную с атрибутом -i, присваиваемое ей значение всегда будет вычисляться в математическом контексте. Это и произошло в нашем примере.

Математический контекст можно объявить явно. Это делает встроенная Bash-команда let.
------------------------------
Оператор (( имеет две формы.

1) Арифметическая оценка (arithmetic evaluation).
   
   Это синоним команды let. Возвращает код ноль при успешном выполнении и единицу в случае ошибки. Вычислив выражение, Bash подставит вместо него код возврата.
   
   ((var = 12 + 7))

2) Арифметическая подстановка (arithmetic expansion).
   
   В этом случае Bash вычислит значение выражения. Затем он подставит это значение вместо выражения. Это отличается от поведения первой формы оператора ((, при которой подставляется код возврата.
   
   var=$((12 + 7))

Вторая форма оператора (( является частью POSIX-стандарта. Используйте её для переносимого кода. Первая форма оператора (( доступна только в интерпретаторах Bash, ksh и zsh.

В операторе (( имена переменных можно указывать без знака доллар $. Bash всё равно правильно подставит их значения.
------------------------------
Порядок выполнения можно изменить с помощью круглых скобок “( )”. Их содержимое называется подвыражением (subexpression). Bash вычисляет значения подвыражений в первую очередь. Если подвыражений несколько, они вычисляются по порядку.
------------------------------
Предположим, в вашем коде используется числовая константа. Её значение можно указать в произвольной системе счисления. Для выбора системы счисления используйте префикс.

Префиксы для указания системы счисления константы:

0    Восьмеричная        echo "$((071)) = 57"
0x   Шестнадцатеричная   echo "$((0xFF)) = 255"
0X   Шестнадцатеричная   echo "$((0XFF)) = 255"
<основание>#  Система с указанным основанием от 2 до 64
------------------------------
При выводе на экран или в файл Bash всегда переводит значения чисел в десятичную систему.
Встроенная команда printf меняет формат вывода чисел.

printf "%x\n" 250

Эта команда выведет на экран число 250 в шестнадцатеричной системе.
Аналогично можно вывести и значение переменной.
==============================
Арифметические действия
==============================
Операция нахождения остатка в Bash обозначается знаком процент %.
В некоторых языках этим же символом обозначается операция modulo. Это два разных действия.

Для расчёта modulo применяется та же формула, что и для остатка. Отличается только выбор неполного частного q. Для нахождения остатка, частное вычисляется по формуле:

q = a / b

Результат округляется к меньшему по модулю числу. То есть все знаки после запятой отбрасываются.
Неполное частное для modulo считается по-разному в зависимости от знаков a и b. Если знаки совпадают, формула для частного та же.

Если знаки разные, формула другая:

q = (a / b) + 1

В обоих случаях результат округляется к меньшему по модулю числу.

Однако при делении чисел с разными знаками остаток может быть отрицательным. Запомните простое правило: у остатка r всегда такой же знак, что и у делимого a. Если знаки различаются, значит вы нашли modulo.

Операция modulo широко применяется в криптографии.-----------------------------




