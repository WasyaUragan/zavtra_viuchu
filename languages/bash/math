###
==============================
Арифметические выражения
==============================
В Bash для арифметики с плавающей точкой используйте калькулятор bc или dc.
------------------------------
Представление целых чисел

Целые числа могут быть положительными и отрицательными. Соответствующий им тип данных называется целое (integer).
Если переменная целого типа принимает только положительные значения, она называется беззнаковой (unsigned).
Если допустимы как положительные, так и отрицательные значения — это переменная со знаком (signed).

Наиболее распространены три способа представления целых в памяти компьютера:

1) Прямой код (signed magnitude representation или SMR).
2) Обратный код (ones’ complement).
3) Дополнительный код (two’s complement).
------------------------------
Прямой код
1. Для записи только положительных целых (беззнаковых).
2. Для записи как положительных, так и отрицательных целых (со знаком).

Предположим, что на число выделен один байт памяти. Тогда в прямом коде можно сохранить целые беззнаковые числа от 0 до 255.
Прямой код можно использовать вторым способом. Он позволяет хранить целые числа со знаком. Для этого старший бит числа резервируется для знака. Поэтому на значение числа остаётся меньше битов. Например, отведём для хранения числа один байт памяти. Один бит уйдёт на знак. Останется только семь битов на значение числа.

Из-за знака теперь нельзя сохранить числа больше 127 в одном байте. По этой же причине минимальное отрицательное число равно -127
------------------------------
Обратный код

У любого современного
процессора есть стандартный модуль под названием сумматор. Он побитово складывает два числа. Если применить его для нашей задачи, получим следующее:

10 + (-5) = 0000 1010 + 1000 0101 = 1000 1111 = -15

Результат неверный. Это означает, что сумматор не подходит для сложения целых в прямом коде. Проблема в том, что при сложении не учитывается старший бит числа.

Принцип работы обратного кода очень похож на прямой код. Старший бит отводится под знак. Остальные биты хранят значение числа. Отличие в том, что для отрицательных чисел все биты значения инвертируются. То есть нули становятся единицами, а единицы — нулями. Биты значения положительных чисел не инвертируются.

Вместимость памяти при использовании прямого и обратного кодов одинакова. В одном байте по-прежнему можно сохранить числа от -127 до 127.

Представим 10 и -5 в обратном коде. Затем сложим их с помощью сумматора.

10 + (-5) = 0000 1010 + 1111 1010 = 1 0000 0100

Обратите внимание, что в результате сложения произошло переполнение. Старшая единица не поместилась в один байт, отведённый под число. В этом случае она отбрасывается.

Отброшенная единица влияет на конечный результат. Нужен второй этап вычисления, чтобы её учесть.

На этом этапе просто добавим единицу к результату:

0000 0100 + 0000 0001 = 0000 0101 = 5

Если в результате сложения получилось отрицательное число, второй этап вычисления не нужен.

У прямого кода есть вторая проблема: представление нуля двумя способами. Её обратный код решить не смог.
------------------------------
Дополнительный код

Дополнительный код решает обе проблемы прямого кода. Во-первых, он позволяет стандартному сумматору складывать отрицательные числа. В обратном коде это действие выполняется в два этапа. В дополнительном коде достаточно одного. Во-вторых, ноль представляется одним единственным способом. Положительные числа в дополнительном коде выглядят так же, как и в прямом. Старший знаковый бит равен нулю. Остальные биты хранят значение числа. У отрицательных чисел старший бит равен единице. Биты значения инвертируются, как в обратном коде. Затем к результату прибавляется единица.

Вместимость памяти при использовании дополнительного кода не меняется. По-прежнему в одном байте можно сохранить числа от -127 до 127.

Дополнительный код позволил стандартному сумматору складывать отрицательные числа. Результат сложения вычисляется за один этап. Поэтому в отличие от обратного кода нет потери производительности. Дополнительный код решил проблему представления нуля. Все биты этого числа — нули. Других вариантов нет. Поэтому сравнивать числа стало проще. Во всех современных компьютерах целые представляются в дополнительном коде.
==============================
