###
==============================
Арифметические выражения
==============================
В Bash для арифметики с плавающей точкой используйте калькулятор bc или dc.
------------------------------
Представление целых чисел

Целые числа могут быть положительными и отрицательными. Соответствующий им тип данных называется целое (integer).
Если переменная целого типа принимает только положительные значения, она называется беззнаковой (unsigned).
Если допустимы как положительные, так и отрицательные значения — это переменная со знаком (signed).

Наиболее распространены три способа представления целых в памяти компьютера:

1) Прямой код (signed magnitude representation или SMR).
2) Обратный код (ones’ complement).
3) Дополнительный код (two’s complement).
------------------------------
Прямой код
1. Для записи только положительных целых (беззнаковых).
2. Для записи как положительных, так и отрицательных целых (со знаком).

Предположим, что на число выделен один байт памяти. Тогда в прямом коде можно сохранить целые беззнаковые числа от 0 до 255.
Прямой код можно использовать вторым способом. Он позволяет хранить целые числа со знаком. Для этого старший бит числа резервируется для знака. Поэтому на значение числа остаётся меньше битов. Например, отведём для хранения числа один байт памяти. Один бит уйдёт на знак. Останется только семь битов на значение числа.

Из-за знака теперь нельзя сохранить числа больше 127 в одном байте. По этой же причине минимальное отрицательное число равно -127
------------------------------
Обратный код

У любого современного
процессора есть стандартный модуль под названием сумматор. Он побитово складывает два числа. Если применить его для нашей задачи, получим следующее:

10 + (-5) = 0000 1010 + 1000 0101 = 1000 1111 = -15

Результат неверный. Это означает, что сумматор не подходит для сложения целых в прямом коде. Проблема в том, что при сложении не учитывается старший бит числа.

Принцип работы обратного кода очень похож на прямой код. Старший бит отводится под знак. Остальные биты хранят значение числа. Отличие в том, что для отрицательных чисел все биты значения инвертируются. То есть нули становятся единицами, а единицы — нулями. Биты значения положительных чисел не инвертируются.

Вместимость памяти при использовании прямого и обратного кодов одинакова. В одном байте по-прежнему можно сохранить числа от -127 до 127.

Представим 10 и -5 в обратном коде. Затем сложим их с помощью сумматора.

10 + (-5) = 0000 1010 + 1111 1010 = 1 0000 0100

Обратите внимание, что в результате сложения произошло переполнение. Старшая единица не поместилась в один байт, отведённый под число. В этом случае она отбрасывается.

Отброшенная единица влияет на конечный результат. Нужен второй этап вычисления, чтобы её учесть.

На этом этапе просто добавим единицу к результату:

0000 0100 + 0000 0001 = 0000 0101 = 5

Если в результате сложения получилось отрицательное число, второй этап вычисления не нужен.

У прямого кода есть вторая проблема: представление нуля двумя способами. Её обратный код решить не смог.
------------------------------
Дополнительный код

Дополнительный код решает обе проблемы прямого кода. Во-первых, он позволяет стандартному сумматору складывать отрицательные числа. В обратном коде это действие выполняется в два этапа. В дополнительном коде достаточно одного. Во-вторых, ноль представляется одним единственным способом. Положительные числа в дополнительном коде выглядят так же, как и в прямом. Старший знаковый бит равен нулю. Остальные биты хранят значение числа. У отрицательных чисел старший бит равен единице. Биты значения инвертируются, как в обратном коде. Затем к результату прибавляется единица.

Вместимость памяти при использовании дополнительного кода не меняется. По-прежнему в одном байте можно сохранить числа от -127 до 127.

Дополнительный код позволил стандартному сумматору складывать отрицательные числа. Результат сложения вычисляется за один этап. Поэтому в отличие от обратного кода нет потери производительности. Дополнительный код решил проблему представления нуля. Все биты этого числа — нули. Других вариантов нет. Поэтому сравнивать числа стало проще. Во всех современных компьютерах целые представляются в дополнительном коде.

Сложение чисел в доп коде:
1 + 0 = 1
1 + 1 = 0
0 + 0 = 1
==============================
Оператор ((
==============================
Bash выполняет целочисленную арифметику в математическом контексте (math context).

declare -i var=12+7

В результате переменная будет равна числу 19, а не строке “12+7”. Если объявить переменную с атрибутом -i, присваиваемое ей значение всегда будет вычисляться в математическом контексте. Это и произошло в нашем примере.

Математический контекст можно объявить явно. Это делает встроенная Bash-команда let.
------------------------------
Оператор (( имеет две формы.

1) Арифметическая оценка (arithmetic evaluation).
   
   Это синоним команды let. Возвращает код ноль при успешном выполнении и единицу в случае ошибки. Вычислив выражение, Bash подставит вместо него код возврата.
   
   ((var = 12 + 7))

2) Арифметическая подстановка (arithmetic expansion).
   
   В этом случае Bash вычислит значение выражения. Затем он подставит это значение вместо выражения. Это отличается от поведения первой формы оператора ((, при которой подставляется код возврата.
   
   var=$((12 + 7))

Вторая форма оператора (( является частью POSIX-стандарта. Используйте её для переносимого кода. Первая форма оператора (( доступна только в интерпретаторах Bash, ksh и zsh.

В операторе (( имена переменных можно указывать без знака доллар $. Bash всё равно правильно подставит их значения.
------------------------------
Порядок выполнения можно изменить с помощью круглых скобок “( )”. Их содержимое называется подвыражением (subexpression). Bash вычисляет значения подвыражений в первую очередь. Если подвыражений несколько, они вычисляются по порядку.
------------------------------
Предположим, в вашем коде используется числовая константа. Её значение можно указать в произвольной системе счисления. Для выбора системы счисления используйте префикс.

Префиксы для указания системы счисления константы:

0    Восьмеричная        echo "$((071)) = 57"
0x   Шестнадцатеричная   echo "$((0xFF)) = 255"
0X   Шестнадцатеричная   echo "$((0XFF)) = 255"
<основание>#  Система с указанным основанием от 2 до 64
------------------------------
При выводе на экран или в файл Bash всегда переводит значения чисел в десятичную систему.
Встроенная команда printf меняет формат вывода чисел.

printf "%x\n" 250

Эта команда выведет на экран число 250 в шестнадцатеричной системе.
Аналогично можно вывести и значение переменной.
==============================
Арифметические действия
==============================
Операция нахождения остатка в Bash обозначается знаком процент %.
В некоторых языках этим же символом обозначается операция modulo. Это два разных действия.

Для расчёта modulo применяется та же формула, что и для остатка. Отличается только выбор неполного частного q. Для нахождения остатка, частное вычисляется по формуле:

q = a / b

Результат округляется к меньшему по модулю числу. То есть все знаки после запятой отбрасываются.
Неполное частное для modulo считается по-разному в зависимости от знаков a и b. Если знаки совпадают, формула для частного та же.

Если знаки разные, формула другая:

q = (a / b) + 1

В обоих случаях результат округляется к меньшему по модулю числу.

Однако при делении чисел с разными знаками остаток может быть отрицательным. Запомните простое правило: у остатка r всегда такой же знак, что и у делимого a. Если знаки различаются, значит вы нашли modulo.

Операция modulo широко применяется в криптографии.
==============================
Битовые операции 
==============================
— это ещё один тип математических действий. Эти операции активно используется в программировании. Своё название они получили потому, что выполняются над каждым битом числа по отдельности.
------------------------------
Побитовое отрицание

В Bash отрицание обозначается знаком тильда ∼.

Чтобы выполнить побитовое отрицание, замените значение каждого бита числа на противоположное. То есть каждая единица заменяется на ноль и наоборот.

5 = 101
~5 = 010

В Bash под целые числа отводится 64 бита независимо от наличия знака.

$ echo $((~5))
-6 (знаковое целое)

$ printf "%llu\n" $((~5))
18446744073709551610 (беззнаковое целое)

Числа 18446744073709551610 и -6 равны с точки зрения Bash. Потому что все их биты в памяти совпадают.
------------------------------
Побитовое И, ИЛИ, исключающее ИЛИ

Побитовое И выполняется над двумя числами. Они представляются в двоичном виде. Затем над каждой соответствующей парой битов двух чисел выполняется логическое И.

1. Представить оба операнда в двоичном виде.
2. Если число битов в одном операнде меньше чем в другом, дополнить его слева нулями.
3. Применить логическое И к каждой паре битов, которые стоят на одинаковых позициях. То есть выполнить логическое И с первым битом первого числа и с первым битом второго числа. Затем перейти ко второму биту и т.д.

Операция AND (&) работает по принципу:
Результат = 1, только если ОБА бита = 1, иначе 0.

В Bash операция побитового И обозначается знаком амперсанд &.

Побитовое AND часто используется для проверки чётности числа:
n & 1 (0 — чётное, 1 — нечётное).
------------------------------
Операция побитового ИЛИ (OR) выполняется аналогично побитовому И. Только вместо логического И над каждой парой битов чисел выполняется логическое ИЛИ.

В Bash побитовое ИЛИ обозначается знаком |.

Главное правило: Результат равен 1, если хотя бы один из битов равен 1.
------------------------------
Операция побитового исключающего ИЛИ (XOR) похожа на побитовое ИЛИ. В ней над каждой парой битов операндов выполняется логическое исключающее ИЛИ. Исключающее ИЛИ возвращает ложь если операнды не равны. В противном случае результат операции — истина.

В Bash исключающее ИЛИ обозначается символом ^.
==============================
Битовые сдвиги
==============================
Битовым сдвигом называется смена позиций битов числа.

Есть три типа сдвигов:
1. Логический
2. Арифметический
3. Циклический

Операция битового сдвига принимает два операнда. Первый — это число, над которым выполняется операция. Второй — количество битов, на которое происходит сдвиг.
------------------------------
Чтобы выполнить логический сдвиг, представьте исходное число в двоичном виде. Предположим, что выполняется сдвиг вправо на два бита. Тогда два крайние бита числа справа отбрасываются. Вместо них слева добавляются нули. Аналогично выполняется сдвиг влево. Два бита слева отбрасываются. Два нуля справа добавляются.
------------------------------
Рассмотрим второй тип сдвига — арифметический. Влево он выполняется точно так же, как и логический сдвиг.

Арифметический сдвиг вправо отличается от логического. Чтобы его выполнить, отбросьте нужное количество битов справа. Затем дополните результат битами слева. Их значение должно совпадать со старшим битом числа. Если он равен единице, добавляем справа единицы. В противном случае добавляем нули. Благодаря этому, после сдвига знак числа не меняется.

Операции << и >> интерпретатора Bash выполняют арифметические сдвиги.
------------------------------
Циклический сдвиг редко применяется в программировании. Поэтому большинство языков не имеет для него встроенного оператора. В циклическом сдвиге отброшенные биты появляются на освободившемся месте с другого конца числа.
==============================
Логические операции
==============================
Для сравнения целых чисел в конструкции if оператор [[ неудобен. В нём отношения между числами обозначают двухбуквенные сокращения. Например, -gt для отношения больше. Удобнее использовать оператор (( в форме арифметической оценки. Тогда сокращения заменяются на привычные символы сравнения чисел (>, <, =).

if ((var < 5)) 
then
  echo "Значение var меньше 5"
fi
------------------------------
когда нужно получить результат вычислений:
арифметическая подстановка $((...)) 
истина - 1, ложь - 0

для условий, циклов и присваиваний:
арифметическая оценка ((...))
истина - 0, ложь - 1..255 (POSIX)

Обратите внимание на важное отличие арифметической оценки и подстановки. Согласно POSIX-стандарту, любая программа или команда при успешном выполнении возвращает ноль. При ошибке возвращается код возврата от 1 до 255. Этот код интерпретируется так: ноль означает истину, а не ноль — ложь. В этом смысле результат арифметической подстановки инвертирован, а оценки нет.

Арифметическая оценка — это синоним команды let. Значит она подчиняется требованиям POSIX-стандарта, как и любая другая команда. Арифметическая подстановка выполняется в контексте другой команды. Поэтому результат её работы зависит от реализации интерпретатора. В Bash если условие в операторе (( в форме подстановки истинно, будет возвращена единица. В противном случае оператор возвращает ноль. Такое поведение соответствует правилам вывода логических выражений языка C.

Логические операции обычно применяют в форме арифметической оценки оператора ((. Они работают так же, как логические операторы Bash.

При делении на 0 или синтаксических ошибках обе конструкции прервут выполнение скрипта (если не включен set -e).
==============================
Инкремент и декремент
==============================
Инкремент увеличивает значение переменной на единицу. Декремент — уменьшает на единицу.

У них есть две формы: постфиксная и префиксная. Они записываются по-разному. В постфиксной форме знаки ++ и – идут после имени переменной, а в префиксной — до.

Инкремент и декремент упрощают работу со счётчиком. Кроме того современные процессоры выполняют эти операции на аппаратном уровне. Поэтому они работают быстрее, чем сложение и вычитание с присваиванием.
------------------------------
Чем отличаются префиксный и постфиксный инкременты?

Если выражение состоит только из операции инкремента, то результат будет одинаковым для обеих форм.

Разница между формами инкремента появляется, при присваивании результата переменной.

Рассмотрим следующий пример:

var=1
((result = ++var))

В результате значения обеих переменных result и var станут двум. Это означает, что префиксный инкремент сначала прибавляет единицу, а потом возвращает результат сложения. Если расписать префиксный инкремент по отдельным командам, получится следующее:

var=1
((var = var + 1))
((result = var))

Поведение постфиксного инкремента отличается. Заменим форму инкремента в нашем примере:

var=1
((result = var++))

После выполнения команд в переменную result запишется единица, а в var — двойка. Постфиксный инкремент сначала возвращает значение, а потом прибавляет единицу.

Распишем постфиксный инкремент по отдельным командам:

var=1
((tmp = var))
((var = var + 1))
((result = tmp))

Обратите внимание на порядок выполнения постфиксного инкремента. Сначала var увеличивается на единицу. Только после этого её прошлое значение возвращается в качестве результата. Поэтому прошлое значение var пришлось сохранить во временную переменную tmp. Постфиксная и префиксная формы декремента работают аналогично инкременту.

Всегда используйте префиксную форму инкремента и декремента вместо постфиксной. Во-первых, она быстрее выполняется процессором. Потому что не надо сохранять текущее значение переменной. Во-вторых, с постфиксной формой легче допустить ошибку из-за неочевидного порядка присваивания.
==============================
Тернарная условная операция
==============================
Тернарная условная операция также известна как тернарный оператор.

Тернарный оператор представляет собой компактную форму конструкции if.
------------------------------
if ((var < 10))
then
((result = 0))
else
((result = var))
fi

равно

((result = var < 10 ? 0 : var))
------------------------------
Тернарный оператор состоит из условного выражения и двух действий. В общем случае он выглядит так:

(( УСЛОВИЕ ? ДЕЙСТВИЕ 1 : ДЕЙСТВИЕ 2 ))
------------------------------
Bash допускает тернарный оператор только в арифметической оценке и подстановке. Это означает, что в качестве условия и действий можно указать только арифметические выражения. Вызов команд Bash или внешних утилит из тернарного оператора невозможен. Такого ограничения нет в других языках программирования.

Используйте тернарный оператор как можно чаще. Это считается хорошей практикой.
==============================