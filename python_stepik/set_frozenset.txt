Предположим, вы хотите объединить два множества, у которых есть несколько общих ключей. Поскольку множество должно содержать только уникальные значения, объединение двух множеств будет иметь всего лишь один такой одинаковый ключ.

создать множество
>>> empty_set = set()
>>> even_numbers = {0, 2, 4, 6, 8}

Порядок ключей в множестве не имеет значения

Вы можете создать множество из списка, строки, кортежа или словаря, отбрасывая любые повторяющиеся значения.
Когда вы передаете функции set() словарь, она возвращает только ключи

Добавим во множество еще один элемент
>>> s = set((1,2,3))
>>> s
{1, 2, 3}
>>> s.add(4)
>>> s
{1, 2, 3, 4}

удалить выбранное значение из множества
>>> s.remove(3)

проитерировать по всем элементам множества
>>> furniture = set(('sofa', 'ottoman', 'table'))
>>> for piece in furniture:
... print(piece)

если вам нужно проверить наличие сразу нескольких значений множества
оператор пересечения множеств (&):
>>> for name, contents in drinks.items():
... if contents & {'vermouth', 'orange juice'}:
... print(name)

Функция intersection() делает то же самое:
>>> a = {1, 2}
>>> b = {2, 3}
>>> a & b
{2}
>>> a.intersection(b)
{2}

объединение (члены обоих множеств), оператор | или функцию множества union():
>>> a | b
{1, 2, 3}
>>> a.union(b)
{1, 2, 3}

Разность множеств (члены только первого множества, но не второго) можно получить с помощью символа — или функции difference():
>>> a – b
{1}
>>> a.difference(b)
{1}

Для выполнения исключающего ИЛИ (элементы или первого, или второго множества, но не общие) используйте оператор ^ или функцию symmetric_difference():
>>> a ^ b
{1, 3}
>>> a.symmetric_difference(b)
{1, 3}

Проверить, является ли одно множество подмножеством другого (когда все члены первого множества являются членами второго), можно с помощью оператора <= или функции issubset():
>>> a <= b
False
>>> a.issubset(b)
False

любое множество Является подмножеством самого себя.

Надмножество противоположно подмножеству (все члены второго множества являются также членами первого). Для определения этого используется оператор >= или функция issuperset():
>>> a >= b
False
>>> a.issuperset(b)
False

Любое множество является надмножеством самого себя

Включение множества
{ выражение for выражение in итерабельный объект}
>>> a_set = {number for number in range(1,6) if number % 3 == 1}
>>> a_set
{1, 4}

Создаем неизменяемое множество с помощью функции frozenset()
>>> frozenset([3, 2, 1])
frozenset({1, 2, 3})
>>> frozenset(set([2, 1, 3]))
frozenset({1, 2, 3})
>>> frozenset({3, 1, 2})
frozenset({1, 2, 3})
>>> frozenset( (2, 3, 1) )
frozenset({1, 2, 3})




























