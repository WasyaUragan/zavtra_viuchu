В Python словарь также принято называть dict.
Порядок элементов в нем не имеет значения,

Чтобы создать словарь, нужно заключить в фигурные скобки ({}) разделенные запятыми пары ключ : значение.
Ключ чаще всего представляет собой строку, но может быть любым из неизменяемых типов

Традиционный способ создания словаря:
bierce = {
	"day": "A period of twenty-four hours, mostly misspent",
	"positive": "Mistaken at the top of one's voice",
	"misfortune": "The kind of fortune that never misses",
 	}

С использованием dict():
имена аргументов должны представлять собой корректные имена переменных (в них не должны использоваться пробелы и ключевые слова)

>>> acme_customer = dict(first="Wile", middle="E", last="Coyote")
>>> acme_customer
{'first': 'Wile', 'middle': 'E', 'last': 'Coyote'}

Добавить элемент в словарь
>>> pythons = {
... 'Chapman': 'Graham',
... 'Cleese': 'John',
... }

>>> pythons['Gilliam'] = 'Gerry'
{'Chapman': 'Graham', 'Cleese': 'John', 'Gilliam': 'Gerry'}

ключи в словаре должны быть уникальными.
Если вы примените ключ более одного раза, победит последнее значение:

Получаем элемент словаря
>>> some_pythons['John']
'Cleese'

проверить, имеется ли заданный ключ
'Groucho' in pythons

Второй способ — использовать специальную функцию словаря get().
Если такого ключа нет, вы получите опциональное значение:
>>> pythons.get('Groucho', 'Not a Python')
'Not a Python'

использовать функцию keys(), чтобы получить все ключи словаря
функция возвращает dict_keys() — итерабельное представление ключей
В Python 3 надо вызвать функцию list(), чтобы преобразовать dict_keys в список.

>>> signals = {'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'}
>>> signals.keys()
dict_keys(['green', 'red', 'yellow'])

получить все значения словаря:
>>> list(signals.values())
['go', 'smile for the camera', 'go faster']

получить все пары «ключ — значение» из словаря
>>> list(signals.items())
[('green', 'go'), ('red', 'smile for the camera'), ('yellow', 'go faster')]

Количество пар «ключ — значение» определяется так:
>>> len(signals)

Объединяем словари
>>> first = {'a': 'agony', 'b': 'bliss'}
>>> second = {'b': 'bagels', 'c': 'candy'}
>>> {**first, **second}
{'a': 'agony', 'b': 'bagels', 'c': 'candy'}

копирование в Python
Глубокая копия создает новую и отдельную копию всего объекта или списка со своим уникальным адресом памяти. Это означает, что любые изменения, внесенные вами в новую копию объекта или списка, не будут отражаться в исходной. Этот процесс происходит следующим образом, сначала создается новый список или объект, а затем рекурсивно копируя все элементы из исходного в новый.

Поверхностное копирование также создает отдельный новый объект или список, но вместо копирования дочерних элементов в новый объект, оно просто копирует ссылки на их адреса памяти. Следовательно, если вы сделаете изменение в исходном объекте, оно будет отражено в скопированном объекте, и наоборот. Короче говоря, обе копии зависят друг от друга.

Разница между глубоким и поверхностным копированием
При глубоком копирование новый объект хранит копии значений объекта, тогда как при поверхностным копирование новый объект хранить ссылки на исходный адрес памяти
Глубокая копия не отражает изменения, внесенные в новый/скопированный объект в исходном объекте; в то время как поверхностная копия отражает

скопировать ключи и значения из одного словаря в другой
pythons = {
... 'Chapman': 'Graham',
... 'Cleese': 'John',
}
others = { 'Marx': 'Groucho', 'Howard': 'Moe' }
pythons.update(others)
pythons
{'Chapman': 'Graham', 'Cleese': 'John', 'Palin': 'Michael', 'Marx': 'Groucho', 'Howard': 'Moe'}

Удаляем элементы по их ключу
>>> del pythons['Marx']

Получаем элемент по ключу и удаляем его с помощью функции pop()
В этой функции объединены функции get() и del.
Если вы передадите функции pop() ключ в качестве аргумента и такой ключ имеется в словаре, она вернет соответствующее значение и удалит пару. Если ключа в словаре нет, будет сгенерировано исключение

удалить все ключи и значения из словаря
>>> pythons.clear()

Как и в случае со списками, если вы внесете в словарь изменение, оно отразится на всех именах, которые на него ссылаются

Чтобы скопировать ключи и значения из одного словаря в другой и запретить изменяться остальным словарям при изменении данных в одном из них, можно воспользоваться функцией copy.deepcopy()

Как и в случае со списками и кортежами, рассмотренными в предыдущей главе, словари можно сравнивать с помощью операторов == и !=

Итерируем по словарям с помощью for и in
>>> accusation = {'room': 'ballroom', 'weapon': 'lead pipe',
... 'person': 'Col. Mustard'}
>>> for card in accusation: # или for card in accusation.keys():
... print(card)

Для того чтобы проитерировать не по ключам, а по значениям, используйте функцию values():
>>> for value in accusation.values():
... print(value)

Для получения пар «ключ — значение» подходит функция items():
>>> for item in accusation.items():
... print(item)

Присвоить значение кортежа другим переменным
>>> for card, contents in accusation.items():
... print('Card', card, 'has the contents', contents)

У словарей также существуют включения.
Простейшая форма выглядит знакомо:
{выражение для ключа : выражение для значения for выражение in итерабельный объект}
>>> word = 'letters'
>>> letter_counts = {letter: word.count(letter) for letter in word}
>>> letter_counts
{'l': 1, 'e': 2, 't': 2, 'r': 1, 's': 1}

Следующий фрагмент больше соответствует «питонскому» стилю:
>>> word = 'letters'
>>> letter_counts = {letter: word.count(letter) for letter in set(word)}
>>> letter_counts
{'t': 2, 'l': 1, 'e': 2, 'r': 1, 's': 1}
Порядок ключей словаря изменился по сравнению с предыдущим примером, поскольку вызов set(word) возвращает буквы в другом порядке.

По аналогии со списковыми включениями для генератора словарей также можно использовать условные проверки if и более одного блока for:
{выражение для ключа : выражение для значения for выражение in итерабельный объект if условие}
>>> vowels = 'aeiou'
>>> word = 'onomatopoeia'
>>> vowel_counts = {letter: word.count(letter) for letter in set(word)
if letter in vowels}
>>> vowel_counts
{'e': 1, 'i': 1, 'o': 4, 'a': 2}



















