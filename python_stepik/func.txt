#####
Функция — это именованный фрагмент кода, отделенный от других.
Функция может принимать любое количество аргументов (включая ноль) любого типа. Она может возвращать любое количество результатов (также включая ноль) любого типа.
определить функцию:
-------------------------------------------------------------------------------------------------------------------
>>> def do_nothing():
... pass

pass демонстрирует, что функция ничего не делает. Оно эквивалентно утверждению «Эта страница специально оставлена пустой»
-------------------------------------------------------------------------------------------------------------------
Функцию можно вызвать, просто написав ее имя и скобки.
>>> do_nothing()
>>>
-------------------------------------------------------------------------------------------------------------------
Определим функцию echo(), имеющую один параметр anything. Она использует оператор return, чтобы отправить значение anything вызывающей стороне дважды, разделив их пробелом:
>>> def echo(anything):
... return anything + ' ' + anything
...
>>>
-------------------------------------------------------------------------------------------------------------------
>>> echo('Rumplestiltskin')
'Rumplestiltskin Rumplestiltskin'
Значения, которые вы передаете в функцию при вызове, называются аргументами. Когда вы вызываете функцию с аргументами, значения этих аргументов копируются в соответствующие параметры внутри функций.

значения вне функции называются аргументами, а значения внутри — параметрами.
-------------------------------------------------------------------------------------------------------------------
Если функция не вызывает return явно, вызывающая сторона получит результат None:
>>> print(do_nothing())
None

None — это специальное значение в Python, которое заполняет собой пустое место, если функция ничего не возвращает. Оно не является булевым значением False, хоть и похоже на него при проверке булевой переменной.

Чтобы отличить None от булева значения False, используйте оператор is:
>>> thing = None
>>> if thing is None:
... print("It's nothing")
... else:
... print("It's something")
...
It's nothing

None потребуется вам, чтобы различать отсутствующие значения и пустые. Помните, что целочисленные нули, нули с плавающей точкой, пустые строки (''), списки ([]), кортежи ((,)), словари ({}) и множества (set()) все равны False, но это не то же самое, что None
-------------------------------------------------------------------------------------------------------------------
Наиболее распространенный тип аргументов — это позиционные аргументы, чьи значения копируются в соответствующие параметры по порядку.

Эта функция создает словарь из позиционных входных аргументов и возвращает его:
>>> def menu(wine, entree, dessert):
... return {'wine': wine, 'entree': entree, 'dessert': dessert}
...
>>> menu('chardonnay', 'chicken', 'cake')
{'wine': 'chardonnay', 'entree': 'chicken', 'dessert': 'cake'}
-------------------------------------------------------------------------------------------------------------------
Для того чтобы избежать путаницы с позиционными аргументами, вы можете указать аргументы с помощью имен соответствующих параметров. Порядок следования аргументов в этом случае может быть иным:
>>> menu(entree='beef', dessert='bagel', wine='bordeaux')
{'dessert': 'bagel', 'wine': 'bordeaux', 'entree': 'beef'}
-------------------------------------------------------------------------------------------------------------------
Можно объединять позиционные аргументы и аргументы — ключевые слова.
>>> menu('frontenac', dessert='flan', entree='fish')
{'entree': 'fish', 'dessert': 'flan', 'wine': 'frontenac'}
-------------------------------------------------------------------------------------------------------------------
Если вы вызываете функцию, имеющую как позиционные аргументы, так и аргументы — ключевые слова, то позиционные аргументы необходимо указывать первыми.
-------------------------------------------------------------------------------------------------------------------
Вы можете указать для параметров значения по умолчанию.
>>> def menu(wine, entree, dessert='pudding'):
... return {'wine': wine, 'entree': entree, 'dessert': dessert}
>>> menu('chardonnay', 'chicken')
{'wine': 'chardonnay', 'entree': 'chicken', 'dessert': 'pudding'}

Значение параметров по умолчанию высчитывается, когда функция определяется, а не выполняется. Распространенной ошибкой новичков (а иногда и не совсем новичков) является использование изменяемого типа данных, таких как список или словарь, в качестве параметра по умолчанию.
-------------------------------------------------------------------------------------------------------------------
В следующей проверке функция buggy() каждый раз должна запускаться с новым пустым списком result, добавлять в него аргумент arg, а затем выводить на экран список, состоящий из одного элемента. Однако в этой функции есть баг: список пуст только при первом вызове. Во второй раз список result будет содержать элемент, оставшийся после предыдущего вызова:

>>> def buggy(arg, result=[]):
... result.append(arg)
... print(result)
...
>>> buggy('a')
['a']
>>> buggy('b') # ожидаем увидеть ['b']
['a', 'b']

Функция работала бы корректно, если бы код выглядел так:
>>> def works(arg):
... result = []
... result.append(arg)
... return result
...
>>> works('a')
['a']
>>> works('b')
['b']

Решить проблему можно, передав в функцию что-либо еще, указывающее на то, что вызов является первым:
>>> def nonbuggy(arg, result=None):
... if result is None:
... result = []
... result.append(arg)
... print(result)
...
>>> nonbuggy('a')
['a']
>>> nonbuggy('b')
['b']
-------------------------------------------------------------------------------------------------------------------
Если символ * будет использован внутри функции с параметром, произвольное количество позиционных аргументов сгруппируется в один кортеж.

def print_args(*args):
	print('Positional argument tuple:', args)

print_args(3, 2, 1, 'wait!', 'uh...')
Positional argument tuple: (3, 2, 1, 'wait!', 'uh...')

Если в вашей функции имеются также обяза-
тельные позиционные аргументы, поместите их в начало — *args отправится в конец
списка

>>> def print_more(required1, required2, *args):
print('Need this one:', required1)
print('Need this one too:', required2)
print('All the rest:', args)

При использовании * вам не нужно обязательно называть кортеж аргументов args,
однако это распространенная идиома в Python. Также часто внутри функции ис-
пользуется конструкция *args, как это показано в предыдущем примере, несмотря
на то что технически она является параметром и должна называться *params.

Символ * можно использовать только при описании функции и ее вызове
-------------------------------------------------------------------------------------------------------------------
Вы можете использовать два астериска (**), чтобы сгруппировать аргументы — клю-
чевые слова в словарь

>>> def print_kwargs(**kwargs):
...
print('Keyword arguments:', kwargs)

>>> print_kwargs()
Keyword arguments: {}
>>> print_kwargs(wine='merlot', entree='mutton', dessert='macaroon')
Keyword arguments: {'dessert': 'macaroon', 'wine': 'merlot', 'entree': 'mutton'}

Порядок аргументов будет следующим:
1) обязательные позиционные аргументы;
2) необязательные позиционные аргументы (*args);
3) необязательные аргументы — ключевые слова (**kwargs).

Как и в случае с args, вам не обязательно называть этот аргумент kwargs, однако
такова распространенная практика1.

Синтаксис ** можно применять только при вызове функции или ее опреде-
лении
-------------------------------------------------------------------------------------------------------------------
Знак * в определении функции говорит о том, что параметры start и end нужно предоставлять как именованные аргументы, если мы не хотим использовать их значения по умолчанию:

def print_data(data, *, start=0, end=100):
    for value in (data[start:end]):
        print(value)

data = ['a', 'b', 'c', 'd', 'e', 'f']
print_data(data)
-------------------------------------------------------------------------------------------------------------------
Если аргумент изменяемый, то его значение можно изменить изнутри функции с помощью соответствующего параметра:

outside = ['one', 'fine', 'day']
def mangle(arg):
    arg[1] = 'terrible!'

mangle(outside)
print(outside)
>>> 
['one', 'terrible!', 'day']

Хорошим тоном считается умение избегать подобных ситуаций. Любой документ, являющийся аргументом, может измениться или вернуть новое значение.
-------------------------------------------------------------------------------------------------------------------
прикрепить документацию к определению функции

def echo(anything):
    'echo returns its input argument'
    return anything

применить к документации, если хотите, форматирование:

def print_if_true(thing, check):
    '''
    Prints the first argument if a second argument is true.
    The operation is:
    1. Check whether the *second* argument is true.
    2. If it is, print the *first* argument.
    '''
    if check:
        print(thing)

Для вывода строки документации функции вызовите функцию help(). Передайте ей имя функции
help(echo)

Если хотите увидеть только строку документации без форматирования:
print(echo.__doc__)
-------------------------------------------------------------------------------------------------------------------
Вы можете использовать функции как элементы списков, кортежей, множеств и словарей.
Функции неизменяемы, поэтому их можно применять даже в качестве ключей для словарей.
-------------------------------------------------------------------------------------------------------------------
Замыкания (closure).
Внутренняя функция может действовать как замыкание.
Замыкание — это функция, которая динамически генерируется другой функцией. Обе они могут изменяться и запоминать значения переменных, которые были созданы вне функции.

def knights2(saying):
    def inner2():
        return "We are the knights who say: '%s'" % saying
    return inner2

a = knights2('nihuya_sibe1')
print(a())
-------------------------------------------------------------------------------------------------------------------
лямбда-функция — это анонимная функция, выраженная в виде одного оператора.

def edit_story(words, func):
    for word in words:
        print(func(word))

stairs = ['thud', 'meow', 'thud', 'hiss']

def enliven(word): # больше эмоций!
    return word.capitalize() + '!'

edit_story(stairs, enliven)
Thud!
Meow!
Thud!
Hiss!

равно

edit_story(stairs, lambda word: word.capitalize() + '!')
Thud!
Meow!
Thud!
Hiss!
-------------------------------------------------------------------------------------------------------------------
генератор — это объект, который предназначен для создания последовательностей.
С его помощью вы можете итерировать потенциально огромные последовательности, не создавая и не сохраняя всю последовательность в памяти сразу.

Каждый раз, когда вы итерируете через генератор, он отслеживает, где находился во время последнего вызова, и возвращает следующее значение. Это отличает его от обычной функции, которая не помнит о предыдущих вызовах и всегда начинает работу с первой строки в том же состоянии.

Если вы хотите создать потенциально большую последовательность, вы можете написать функцию-генератор. Это обычная функция, однако она возвращает значение с помощью выражения yield, а не return.

def my_range(first=0, last=10, step=1):
    number = first
    while number < last:
        yield number
        number += step
#возвращает объект генератора:
ranger = my_range(1, 5)
#Мы можем проитерировать по этому объекту генератора:
for x in ranger:
    print(x)


Генератор можно запустить лишь однажды.
Списки, множества, строки и словари существуют в памяти, а генераторы создают свои значения на лету и выдают их по одному с помощью итератора.
Генератор не запоминает значения, поэтому вы не можете перезапустить его или создать резервную копию.
-------------------------------------------------------------------------------------------------------------------
Включения генераторов
заключается в круглые скобки, а не в квадратные или фигурные.

>>> genobj = (pair for pair in zip(['a', 'b'], ['1', '2']))
>>> genobj
<generator object <genexpr> at 0x10308fde0>

>>> for thing in genobj:
... 	print(thing)
...
('a', '1')
('b', '2')
-------------------------------------------------------------------------------------------------------------------
https://pythonworld.ru/osnovy/dekoratory.html
Декоратор — это функция, которая принимает одну функцию в качестве аргумента и возвращает другую функцию.

в первую очередь следует вспомнить, что функции в python являются объектами, соответственно, их можно возвращать из другой функции или передавать в качестве аргумента. Также следует помнить, что функция в python может быть определена и внутри другой функции.

У каждой функции может быть больше одного декоратора.

def my_shiny_new_decorator(function_to_decorate):
    # Внутри себя декоратор определяет функцию-"обёртку". Она будет обёрнута вокруг декорируемой,
    # получая возможность исполнять произвольный код до и после неё.
    def the_wrapper_around_the_original_function():
        print("Я - код, который отработает до вызова функции")
        function_to_decorate() # Сама функция
        print("А я - код, срабатывающий после")
    # Вернём эту функцию
    return the_wrapper_around_the_original_function
    
# Представим теперь, что у нас есть функция, которую мы не планируем больше трогать.
def stand_alone_function():
    print("Я простая одинокая функция, ты ведь не посмеешь меня изменять?")

stand_alone_function()
Я простая одинокая функция, ты ведь не посмеешь меня изменять?

# Однако, чтобы изменить её поведение, мы можем декорировать её, то есть просто передать декоратору,
# который обернет исходную функцию в любой код, который нам потребуется, и вернёт новую,
# готовую к использованию функцию:

stand_alone_function_decorated = my_shiny_new_decorator(stand_alone_function)
stand_alone_function_decorated()

Я - код, который отработает до вызова функции
Я простая одинокая функция, ты ведь не посмеешь меня изменять?
А я - код, срабатывающий после

В качестве альтернативы созданию декоратора вручную можно добавить конструкцию @имя_декоратора перед функцией, которую нужно декорировать:

@document_it
def add_ints(a, b):
	return a + b
add_ints(3, 5)

При этом, естественно, можно использовать несколько декораторов для одной функции, например так:

>>>
>>> def bread(func):
...     def wrapper():
...         print()
...         func()
...         print("<\______/>")
...     return wrapper
...
>>> def ingredients(func):
...     def wrapper():
...         print("#помидоры#")
...         func()
...         print("~салат~")
...     return wrapper
...
>>> def sandwich(food="--ветчина--"):
...     print(food)
...
>>> sandwich()
--ветчина--
>>> sandwich = bread(ingredients(sandwich))
>>> sandwich()

#помидоры#
--ветчина--
~салат~
<\______/>

Однако, все декораторы, которые мы рассматривали, не имели одного очень важного функционала — передачи аргументов декорируемой функции. Собственно, это тоже несложно сделать.

>>> def a_decorator_passing_arguments(function_to_decorate):
...     def a_wrapper_accepting_arguments(arg1, arg2):
...         print("Смотри, что я получил:", arg1, arg2)
...         function_to_decorate(arg1, arg2)
...     return a_wrapper_accepting_arguments
...
>>> # Теперь, когда мы вызываем функцию, которую возвращает декоратор, мы вызываем её "обёртку",
>>> # передаём ей аргументы и уже в свою очередь она передаёт их декорируемой функции
>>> @a_decorator_passing_arguments
... def print_full_name(first_name, last_name):
...     print("Меня зовут", first_name, last_name)
...
>>> print_full_name("Vasya", "Pupkin")
Смотри, что я получил: Vasya Pupkin
Меня зовут Vasya Pupkin
-------------------------------------------------------------------------------------------------------------------
Программы на Python имеют различные пространства имен — разделы, внутри которых определенное имя уникально и не связано с таким же именем в других пространствах имен.
Каждая функция определяет собственное пространство имен.
В основной программе определяется глобальное пространство имен, поэтому переменные, находящиеся в нем, являются глобальными.
Переменная внутри функции - локальная.

Python предоставляет две функции для доступа к содержимому ваших пространств имен:
locals() — возвращает словарь, содержащий имена локального пространства имен;
globals() — возвращает словарь, содержащий имена глобального пространства имен.
-------------------------------------------------------------------------------------------------------------------
если функция вызовет саму себя?1 Это называется рекурсией.

«уплотнить» все подсписки независимо от того, насколько глубоко они вложены.
Для этого отлично подойдет функция-генератор:

def flatten(lol):
    for item in lol:
        if isinstance(item, list):
            for subitem in flatten(item):
                yield subitem
        else:
            yield item

lol = [1, 2, [3,4,5], [6,[7,8,9], []]]

flatten(lol)
print(list(flatten(lol)))

[zhuzhu@workpc ~]$ /bin/python /opt/GIT/zavtra_viuchu/python_stepik/test.py
[1, 2, 3, 4, 5, 6, 7, 8, 9]

выражение yield from, которое позволяет генератору передавать часть работы другому генератору:

def flatten(lol):
    for item in lol:
        if isinstance(item, list):
            yield from flatten(item)
        else:
            yield item

lol = [1, 2, [3,4,5], [6,[7,8,9], []]]

print(list(flatten(lol)))

[zhuzhu@workpc ~]$ /bin/python /opt/GIT/zavtra_viuchu/python_stepik/test.py
[1, 2, 3, 4, 5, 6, 7, 8, 9]
-------------------------------------------------------------------------------------------------------------------
Асинхронные функции
Ключевые слова async и await

Основное различие между асинхронными и обычными функциями заключается в том, что асинхронные могут «передавать управление» вместо того, чтобы заставлять основной поток выполнения ждать до конца их выполнения.
-------------------------------------------------------------------------------------------------------------------
Обрабатываем ошибки с помощью операторов try и except

short_list = [1, 2, 3]
position = 5
try:
    short_list[position]
except:
    print('Need a position between 0 and', len(short_list)-1, ' but got', position)

# Need a position between 0 and 2 but got 5

# Любое исключение является классом, частным случаем класса Exception.
class UppercaseException(Exception):
    pass

words = ['eeenie', 'meenie', 'miny', 'MO']
for word in words:
    if word.isupper():
        raise UppercaseException(word)

#[zhuzhu@workpc ~]$ /bin/python /opt/GIT/zavtra_viuchu/python_stepik/test.py
#Need a position between 0 and 2  but got 5
#Traceback (most recent call last):
#  File "/opt/GIT/zavtra_viuchu/python_stepik/test.py", line 1201, in <module>
#    raise UppercaseException(word)
#__main__.UppercaseException: MO

-------------------------------------------------------------------------------------------------------------------












