git status #текущее состояние
========================================================================================================
git clone git@gitlab.draszi.fintech.ru:cod/ipo-deployment.git -b dev #стянуть проект
git clone --recurse-submodules https://github.com/chaconinc/MainProject  #клонировать с сабмодулями
cd /path/to/dir
git clone=git init+копирование данных из существующего репозитория.
git init #преобразует проект в репозиторий гит.
git init --bare <directory> #репа без рабочего каталога. По сути, не среда разработки, а хранилище.
git init <directory> --template=<template_directory> инициализация + копирование файлов из каталога
$GIT_DIR #задать переменной среды путь для инициализации.
git submodule update --init --recursive #инициализирует субмодуль
========================================================================================================
как создать репу локально и запушить в гитхаб
cd /path/to/repo
git init
создать репу на гитхабе, скопировать урл
git remote add study https://github.com/WasyaUragan/zavtra_viuchu.git
git remote -v
git add .
git commit -m "zametki"
git config --global user.email "ilya.zhuzhukov@yandex.ru"
git config --global user.name "zhuzhu"
git branch -M main
если цепляемся по хттпс, нужно создать на гитхабе токен
Profile - Settings - Developer Settings - Personal Access tokens - Fine-grained token
git push -u study main
========================================================================================================
git push <remote> <branch> #экспортируем ветку.
git push <remote> --force #форсим, если нельзя выполнить ускоренное слияние.
git push <remote> --all #пушим все ветки.
git push --tags #пушим все тэги
git push origin v1.4 #пушим конкретный тэг
git merge #равнозначна git push запущенной из удаленного репозитория
git fetch #импортируем коммит
========================================================================================================
git show v1.4 #содержимое
git tag -l "v1.*" #список
git tag -a v1.4 -m "my version 1.4" #создать аннотированный (доп сведения в мета) тэг, а -m добавить комментарий.
git tag v.1.4 -lw #создать 'облегченный' (это просто имя и указатель на коммит) тэг.
git tag <tag name> <sha> #создать тэг из старого коммита, где SHA-хеш коммита.
git tag -a -f v1.4 <sha> #обновить существующий коммит, где -f где --force.
git tag -d <sha> #удалить тэг
========================================================================================================
git checkout v1.4 #переход к тегу v1.4
git checkout #перемещать указатель HEAD на вершину ветки <branch> или конкретный коммит <sha>
git checkout -b <branch name> #создать ветку
git checkout -b <branch name> <tag name> #перемешает в ветку, локальную репу переводит в состояние тэга
git checkout <file> #откатывает файл в первичное состояние коммита 
========================================================================================================
git log #лог, с описанием коммитов
========================================================================================================
git commit --amend #обновить коммит, пушим форсом.
========================================================================================================
git branch -D branch_name #удалить ветку локально
git push origin :branch_name #стереть ветку удаленно
========================================================================================================
git pull = fetch(загрузка) + merge(слияние) #обновить репу локально
git pull <remote>
git pull --no-commit <remote> #обновить
git pull --verbose #подробный вывод
git merge --no-ff
	#Реинтеграция тематической ветки в master. При этом будет создан merge-коммит, одним из родителей которого будет позиция ветки master, другим — позиция ветки feature, а merge-коммиты несут в себе информацию о моменте объединения веток.
========================================================================================================
git pull --rebase = см. ниже

git config --global branch.autosetuprebase always
	#все команды git pull будут интегрироваться с помощью команды git rebase, а не git merge.
	
git rebase <branch> #перебазирует коммиты из текущей ветки в указанную <branch>
В случае конфликта:
git rebase --abort #отмена в случае конфликта, созд коммиты в процессе перебазирования повисают в воздухе и вскоре будут удалены;
или
Разрешить конфликт в merge-tool'е, подготовить файлы к коммиту, набрав git add %filename%. Проделав это со всеми конфликтными файлами, продолжить процесс rebase-а набрав в консоли
git rebase --continue
или
 Если изменения, в коммитах разных веток являются взаимоисключающими, причем «правильные» изменения сделаны в коммите ветки, куда перебазируются изменения, то нельзя продолжить git rebase --continue, так как изменений в рабочей копии нет. Надо пропустить создание конфликтовавшего коммита, набрав команду
git rebase --skip
========================================================================================================

========================================================================================================


























