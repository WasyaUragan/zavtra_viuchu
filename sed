sed -i 's/SEARCH_REGEX/REPLACEMENT/g' INPUTFILE
-i — По умолчанию sed записывает свой вывод в стандартный вывод. Эта опция указывает sed редактировать файлы на месте. Если указано расширение (например, -i.bak), создается резервная копия исходного файла.
s — Заменяющая команда, вероятно, наиболее часто используемая команда в sed.
/ / / — Символ-разделитель. Это может быть любой символ, но обычно используется символ косой черты ( / ).
SEARCH_REGEX — обычная строка или регулярное выражение для поиска.
REPLACEMENT — строка замены.
g — Флаг глобальной замены. Если флаг g опущен, заменяется только первый экземпляр строки поиска в каждой строке
INPUTFILE — имя файла, для которого вы хотите запустить команду.
Рекомендуется заключать аргумент в кавычки, чтобы метасимволы оболочки не расширялись.

file.txt
123 Foo foo foo 
foo /bin/bash Ubuntu foobar 456

Если флаг g опущен, заменяется только первый экземпляр строки поиска в каждой строке:
sed -i 's/foo/linux/' file.txt
123 Foo linux foo 
linux /bin/bash Ubuntu foobar 456

Замена шаблона в конкретной строке:
sed '3 s/unix/linux/' geekfile.txt

 Указать диапазон строк, в которых требуется заменить определённый шаблон:
sed '1,3 s/unix/linux/' geekfile.txt
sed '2,$ s/unix/linux/' geekfile.txt  # $ указывает на последнюю строку файла

Заменит в каждой строке второе вхождение:
sed 's/unix/linux/2' geekfile.txt

Флаг /p выведет в терминал строки, где производится замена (меняет только 1ое совпадение). Строки, в которых искомый шаблон отсутствует, не дублируются.
sed 's/unix/linux/p' geekfile.txt
Если рядом с флагом /p добавить ключ -n, в терминале отобразятся только строки, где выполнялась замена.
Если использовать только -n, исключив /p, вывод команда не произведёт.

Замена всех вхождений шаблона в строке начиная с n-ого:
sed 's/unix/linux/3g' geekfile.txt

С флагом глобальной замены sed заменяет все вхождения шаблона поиска:
sed -i 's/foo/linux/g' file.txt
123 Foo linux linux
linux /bin/bash Ubuntu linuxbar 456

Удаление n-ой строки:
Синтаксис: sed 'nd' filename.txt
Пример: sed '5d' filename.txt

Удаление последней строки:
Синтаксис: sed '$d' filename.txt

Удаление строк с x> по y:
Синтаксис: sed 'x,yd' filename.txt
Пример: sed '3,6d' filename.txt

Удаление строк с n-ой до последней:
Синтаксис: sed 'n,$d' filename.txt
Пример: sed '12,$d' filename.txt

Вставить после каждой текстовой строки одну пустую:
sed G a.txt 
Вставить две пустые строки:
sed 'G;G' a.txt

Удалить все пустые строки и вставить по одной после каждой текстовой:
sed '/^$/d;G' a.txt

Вставить пустую строку над каждой, содержащей love:
sed '/love/{x;p;x;}' a.txt

Вставить пустую строку после каждой, содержащей love:
sed '/love/G' a.txt

Вставить 5 пробелов слева от каждой строки:
sed 's/^/     /' a.txt

=====================
== Нумерация строк ==
=====================
Пронумеровать каждую строку файла (с левым выравниванием).
sed = a.txt | sed 'N;s/\n/\t/'  # = для нумерации строки, флаг \t для табулирования между номером и предложением



Используйте выражение границы слова ( b ) на обоих концах строки поиска. Это гарантирует, что частичные слова не совпадают.
sed -i 's/bfoob/linux/g' file.txt
123 Foo linux linux
linux /bin/bash Ubuntu foobar 456

Чтобы сделать совпадение с шаблоном нечувствительным к регистру, используйте флаг I В приведенном ниже примере мы используем флаги g и I
sed -i 's/foo/linux/gI' file.txt
123 linux linux linux 
linux /bin/bash Ubuntu linuxbar 456

Если вы хотите найти и заменить строку, содержащую символ-разделитель ( / ), вам нужно будет использовать обратную косую черту ( ), чтобы избежать косой черты. Например, чтобы заменить /bin/bash на /usr/bin/zsh вы должны использовать
sed -i 's//bin/bash//usr/bin/zsh/g' file.txt

Более простой и понятный вариант — использовать другой символ-разделитель. Большинство людей используют вертикальную полосу ( | ) или двоеточие ( : ) , но вы можете использовать любой другой символ:
sed -i 's|/bin/bash|/usr/bin/zsh|g' file.txt
123 Foo foo foo 
foo /usr/bin/zsh Ubuntu foobar 456

Вы также можете использовать регулярные выражения. Например, чтобы найти все трехзначные числа и заменить их строковым number вы должны использовать:
sed -i 's/b[0-9]{3}b/number/g' file.txt
number Foo foo foo 
foo /bin/bash demo foobar number

Заключит в скобки первый символ каждого слова:
echo "Welcome To The Geek Stuff" | sed 's/\(\b[A-Z]\)/\(\1\)/g'

Амперсанд ( & ) соответствует сопоставленному шаблону. Можно использовать несколько раз.
Например, если вы хотите добавить фигурные скобки {} вокруг каждого трехзначного числа, введите:
sed -i 's/b[0-9]{3}b/{&}/g' file.txt
{123} Foo foo foo 
foo /bin/bash demo foobar {456}

Чтобы отредактировать file.txt и сохранить исходный файл как file.txt.bak:
sed -i.bak 's/foo/linux/g' file.txt

Рекурсивный поиск и замена. Это можно сделать с помощью таких команд, как find или grep для рекурсивного поиска файлов в каталоге и передачи имен файлов в sed .

Искать файлы в текущем рабочем каталоге и передавать имена файлов в sed .
find . -type f -exec sed -i 's/foo/bar/g' {} +

Чтобы избежать проблем с файлами, содержащими пробелы в своих именах, используйте параметр -print0 , который указывает find напечатать имя файла, за которым следует нулевой символ, и xargs -0 вывод в sed используя xargs -0 :
find . -type f -print0 | xargs -0 sed -i 's/foo/bar/g'

Чтобы исключить каталог, используйте параметр -not -path . :
find . -type f -not -path '*/.*' -print0 | xargs -0 sed -i 's/foo/bar/g'

Искать и заменять текст только в файлах с определенным расширением, вы будете использовать:
find . -type f -name "*.md" -print0 | xargs -0 sed -i 's/foo/bar/g'

Рекурсивный поиск всех файлов, содержащих шаблон поиска, передача имен файлов в sed :
grep -rlZ 'foo' . | xargs -0 sed -i.bak 's/foo/bar/g'

